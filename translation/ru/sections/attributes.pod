=head1 Атрибуты

Z<attributes>

Именованные сущности в Perl E<mdash> переменные и функции E<mdash> могут иметь
дополнительные метаданные, присоединённые к ним в виде I<атрибутов>. Атрибуты
E<mdash> это произвольные имена и значения, используемые в определённых видах
метапрограммирования (L<code_generation>).

Синтаксис объявления атрибутов довольно неуклюж, а использование атрибутов,
в сущности, скорее искусство, чем наука. Большинство программ никогда их не
используют, но при правильном использовании они обеспечивают ясность и удобство
поддержки.

=head2 Использование атрибутов

Простой атрибут E<mdash> это идентификатор с предшествующим ему двоеточием,
привязанный к объявлению:

=begin programlisting

    my $fortress      B<:hidden>;

    sub erupt_volcano B<:ScienceProject> { ... }

=end programlisting

Эти объявления будут приводить к вызову обработчиков атрибутов, названных
C<hidden> и C<ScienceProject>, если они существуют для соответствующего типа
(скаляров и функций соответственно). Эти обработчики могут делать I<что угодно>.
Если соответствующего обработчика не существует, Perl выбросит исключение
времени компиляции.

X<CPAN; C<Test::Class>>

Атрибуты могут включать списки параметров. Perl обрабатывает эти параметры как
списки строковых и только строковых констант. Модуль C<Test::Class> из CPAN
с успехом использует такие параметрические аргументы:

=begin programlisting

    sub setup_tests          :Test(setup)    { ... }
    sub test_monkey_creation :Test(10)       { ... }
    sub shutdown_tests       :Test(teardown) { ... }

=end programlisting

Атрибут C<Test> указывает на методы, содержащие тестовые проверки, и
опционально устанавливает число проверок, которые метод намерен запустить.
Хотя интроспекция (L<reflection>) этих классов может обнаружить соответствующие
тестовые методы, имея хорошо спроектированные надёжные эвристики, атрибут
C<:Test> делает ваши намерения ясными.

Параметры C<setup> и C<teardown> позволяют тестовым классам определить свои
собственные методы поддержки, не беспокоясь о конфликтах с другими подобными
методами в других классах. Это отделяет проблему указания того, что этот класс
должен делать, от проблемы того, как другие классы делают свою работу, и
обеспечивает высокую гибкость.

=begin tip Атрибуты на практике

X<Catalyst>

Веб-фреймворк Catalyst также использует атрибуты для определения видимости и
поведения методов в веб-приложениях.

=end tip

=head2 Недостатки атрибутов

X<pragmas; C<attributes>>
X<C<attributes> pragma>
X<CPAN; C<Attribute::Handlers>>
X<CPAN; C<Attribute::Lexical>>

У атрибутов есть свои недостатки. Каноническая прагма для работы с атрибутами
(прагма C<attributes>) обозначала свой интерфейс как экспериментальный в течение
многих лет. Базовый модуль C<Attribute::Handlers> Демьена Конвея (Damian
Conway) упрощает их реализацию. C<Attribute::Lexical> Эндрю Мейна (Andrew Main)
E<mdash> более новый подход. По возможности предпочтите использование любого из
них использованию C<attributes>.

X<CPAN; C<Memoize>>

Наихудшая особенность атрибутов E<mdash> их склонность создавать странные
синтаксические действия на расстоянии. Имея фрагмент кода с атрибутами, можете
ли вы предугадать их действие? Хорошо написанная документация помогает, но если
невинно выглядящее объявление лексической переменной где-то сохраняет ссылку на
эту переменную, ваши ожидания относительно срока жизни этой переменной могут
быть ошибочны. Подобным же образом обработчик может обернуть функцию в другую
функцию и заменить её в символьной таблице, не осведомив вас об этом, E<mdash>
рассмотрите атрибут C<:memoize>, который автоматически вызывает базовый
модуль C<Memoize>.

Атрибуты в вашем распоряжении, когда они нужны вам для решения сложных проблем.
Они могут быть очень полезными при правильном использовании E<mdash> но
большинству программ они никогда не понадобятся.
