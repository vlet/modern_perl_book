=head1 Состояния против замыканий

Z<state>

Замыкания (L<closures>) пользуются возможностями лексической области видимости
(L<scope>) для предоставления опосредованного доступа к полу-приватным
переменным. Даже именованные функции могут возпользоваться лексическими
привязками:

=begin programlisting

    {
        my $safety = 0;

        sub enable_safety  { $safety = 1 }
        sub disable_safety { $safety = 0 }

        sub do_something_awesome
        {
            return if $safety;
            ...
        }
    }

=end programlisting

Инкапсуляция функция для обеспечения безопасности позволяет всем трём функциям
разделять состояние, не подвергая лексическую переменную прямому воздействию
внешнего кода. Эта идиома хорошо работает для тех случаев, когда внешний код
должен иметь возможность изменять внутреннее состояние, но слишком тяжеловесна,
если только одной функции нужно управлять состоянием.

Предположим, что каждый сотый покупатель вашего магазина мороженого получает
бесплатную посыпку:

=begin programlisting

    my $cust_count = 0;

    sub serve_customer
    {
        $cust_count++;

        my $order = shift;

        add_sprinkles($order) if $cust_count % 100 == 0;

        ...
    }

=end programlisting

X<state>
X<builtins; C<state>>

Этот подход I<работает>, но создание новой лексической области видимости для
единственной функции создаёт больше сопутствующей сложности, чем нужно.
Встроенная директива C<state> позволяет вам объявлять переменные лексической
области видимости со значением, сохраняющимся между вызовами:

=begin programlisting

    sub serve_customer
    {
        B<state $cust_count = 0;>
        $cust_count++;

        my $order = shift;
        add_sprinkles($order)
            if ($cust_count % 100 == 0);

        ...
    }

=end programlisting

X<C<feature>>
X<C<feature>; C<state>>

Вы должны явно подключить эту возможность, используя модуль C<Modern::Perl>,
прагму C<feature> (L<pragmas>) или требуя конкретную версию Perl 5.10 или выше
(например, с помощью C<use 5.010;> или C<use 5.012;>).

C<state> также работает внутри анонимных функций:

=begin programlisting

    sub make_counter
    {
        return sub
        {
             B<state $count = 0;>
             return $count++;
         }
    }

=end programlisting

E<hellip>хотя у этого подхода немного очевидных преимуществ.

=head1 Состояния против псевдосостояний

Perl 5.10 не рекомендует использование техники из предыдущих версий Perl, с
помощью который вы могли в сущности эмулировать C<state>. Именованная функция
может замкнуться на своей предыдущей лексической области видимости с помощью
злоупотребления нюансом реализации. Использование постфиксного условия,
возвращающего ложь, с объявлением C<my> позволяет избежать I<повторной
инициализации> лексической переменной значением C<undef> или её инициализирующим
значением.

Любое использование постфиксного условного выражения, модифицирующего объявление
лексической переменной, теперь вызывает предупреждение о нерекомендуемости. С
использованием этой техники слишком легко написать непреднамеренно ошибочный
код; вместо этого используйте C<state> там где доступно или настоящие замыкания
в ином случае. Перепишите эту идиому, если она вам попадётся:

=begin programlisting

    sub inadvertent_state
    {
        # my $counter  = 1 if 0; # НЕ РЕКОМЕНДУЕТСЯ; не используйте
        state $counter = 1;      # используйте вместо

        ...
    }

=end programlisting
