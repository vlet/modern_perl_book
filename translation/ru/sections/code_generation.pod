=head1 Кодогенерация

Z<code_generation>

Новички в программировании пишут больше кода, чем нужно, частично из-за
недостаточно близкого знакомства с языками, библиотеками и идиомами, но также и
из-за отсутствия опыта. Они начинают с написания длинного процедурного кода,
затем открывают для себя функции, затем параметры, затем объекты, и E<mdash>
возможно E<mdash> функции высших порядков и замыкания.

По мере того, как вы становитесь лучше как программист, вы будете писать меньше
кода для решения тех же самых задач. Вы будете использовать лучшие абстракции.
Вы будете писать более универсальный код. Вы сможете повторно использовать код
E<mdash> и когда вы сможете добавлять возможности, удаляя код, вы достигнене
чего-то замечательного.

X<metaprogramming>
X<code generation>

Написание программ, пишуших для вас программы E<mdash> I<метапрограммирование>
или I<кодогенерация> E<mdash> предлагает большие возможности для абстракции.
Хотя вы можете устроить огромный бардак, но вы можете и создать изумительные
вещи. Например, техники метапрограммирования делают возможным Moose (L<moose>):

Техника использования C<AUTOLOAD> (L<autoload>) для отсутствующих функций и
методов демонстрирует эту технику в ограниченной форме; система диспетчеризации
функций и методов в Perl 5 позволяет вам настроить, что происходит, когда
нормальный поиск проваливается.

=head2 eval

X<C<eval>; string>
X<builtins; C<eval>>

Самая простая техника кодогенерации E<mdash> это формирование строки, содержащей
фрагмент валидного кода на Perl, и компиляция её с помощью строкового оператора
C<eval>. В отличие от отлавливающего исключения блочного оператора C<eval>,
строковый C<eval> компилирует содержимое строки в текущей области видимости,
включая текущий пакет и лексические привязки.

Наиболее общее использование этой техники E<mdash> предоставление возможности
отката, если вы не можете (или не хотите) загружать опциональную зависимость:

=begin programlisting

    eval { require Monkey::Tracer }
        or eval 'sub Monkey::Tracer::log {}';

=end programlisting

Если C<Monkey::Tracer> недоступен, его функция C<log()> будет существовать, но
ничего не будет делать. Однако этот простой пример обманчив. Правильное
использование C<eval> требует определённой работы; вы должны обработать проблемы
заключения в кавычки для включения переменных в передаваемый в C<eval> код.
Добавьте сложности чтобы интерполировать одни переменные, но не другие:

=begin programlisting

    sub generate_accessors
    {
        my ($methname, $attrname) = @_;

        eval <<"END_ACCESSOR";
        sub get_$methname
        {
            my \$self = shift;
            return \$self->{$attrname};
        }

        sub set_$methname
        {
            my (\$self, \$value) = \@_;
            \$self->{$attrname}  = \$value;
        }
    END_ACCESSOR
    }

=end programlisting

Горе тем, кто забыл обратный слеш! Удачи в объяснении вашей подсветке синтаксиса,
что происходит! Хуже того, каждый вызов строкового C<eval> создаёт новую
структуру данных, представляющую код целиком, и компиляция кода тоже не
бесплатна. Но даже с этими ограничениями эта техника проста.

=head2 Параметризованные замыкания

X<closures; parametric>

Хотя построение аксессоров и мутаторов с помощью C<eval> просто, замыкания
(L<closures>) позволяют вам добавлять параметры в генерируемый код во время
компиляции без необходимости дополнительного вычисления:

=begin programlisting

    sub generate_accessors
    {
        my $attrname = shift;

        my $getter = sub
        {
            my $self = shift;
            return $self->{$attrname};
        };

        my $setter = sub
        {
            my ($self, $value) = @_;
            $self->{$attrname} = $value;
        };

        return $getter, $setter;
    }

=end programlisting

Этот код избегает неприятных проблем с заключением в кавычки и компилирует
каждое замыкание только один раз. Он даже использует меньше памяти из-за
разделения скомпилированного кода между всеми экземплярами замыканий. Всё, что
различается E<mdash> это привязка к лексической переменной C<$attrname>. В
долго выполняющихся процессах, или при большом количестве аксессоров, эта
техника может быть очень полезна.

X<closures; installing into symbol table>
X<symbol tables>

Установка в таблицу символов относительно проста, хоть и некрасива:

=begin programlisting

    {
        my ($get, $set) = generate_accessors( 'pie' );

        no strict 'refs';
        *{ 'get_pie' } = $get;
        *{ 'set_pie' } = $set;
    }

=end programlisting

X<C<*>; sigil>
X<sigils; C<*>>
X<typeglobs>

Странный синтаксис звёздочкиN<Воспринимайте её как I<сигил тайпглоба>, где
I<тайпглоб> E<mdash> Perl-жаргон для E<laquo>таблицы символовE<raquo>.>
разыменовывает хеш, ссылающийся на символ в текущей I<таблице символов>,
являющейся частью текущего пространства имён, содержащего глобально-доступные
символы, такие как глобальные данные пакета, функции и методы. Присваивание
ссылки записи таблицы символов устанавливает или заменяет соответствующую
запись. Чтобы повысить анонимную функцию до метода, сохраните ссылку на эту
функцию в таблице символов.

=begin tip Упрощённые таблицы символов

X<CPAN; C<Package::Stash>>

CPAN-модуль C<Package::Stash> предлагает более приятный интерфейс для подобного
хакинга таблицы символов.

=end tip

X<C<strict> pragma>
X<pragmas; C<strict>>

Присваивание таблице символов символа, содержащего строку, не литеральное
имя переменной, это символическая ссылка. Для этой операции вам нужно отключить
строгую проверку ссылок C<strict>. Многие программы имеют неочевидный баг в
аналогичном коде, так как они присваивают и генерируют в одной строчке:

=begin programlisting

    {
        no strict 'refs';

        *{ $methname } = sub {
            # неочевидный баг: strict refs отключено здесь тоже
        };
    }

=end programlisting

Этот пример отключает ограничения для внешнего блока, так же как и для тела
самой функции. Только присваивание нарушает строгую проверку ссылок, так что
отключайте ограничения только для этой операции.

Если имя метода E<mdash> строковый литерал в вашем исходном коде, а не
содержимое переменной, вы можете присвоить соответсвующему символу напрямую:

=begin programlisting

    {
        no warnings 'once';
        (*get_pie, *set_pie) =
             generate_accessors( 'pie' );
    }

=end programlisting

Прямое присваивание глобу не нарушает ограничения, но упоминание глоба только
раз I<будет> генерировать предупреждение E<laquo>used only onceE<raquo>, если
вы явно не подавите его в области видимости.

=head2 Манипуляции времени компиляции

X<builtins; C<eval>>

В отличие от кода, написанного явно как код, код, генерируемый с помощью
строкового C<eval>, компилируется во время выполнения. Там, где вы можете
ожидать от нормальной функции, что она будет доступна всё время жизни программы,
сгенерированная функция может не быть доступной, когда вы этого ожидаете.

X<C<BEGIN>>

Заставьте Perl выполнять код E<mdash> генерирующий другой код E<mdash> во время
компиляции, обернув его в блок C<BEGIN>. Когда парсер Perl 5 встречает блок
C<BEGIN>, он парсит весь блок. Если он не содержит синтаксических ошибок, блок
будет выполнен немедленно. После его завершения парсинг продолжится, как если бы
не было никаких прерываний.

Разница между записью:

=begin programlisting

    sub get_age    { ... }
    sub set_age    { ... }

    sub get_name   { ... }
    sub set_name   { ... }

    sub get_weight { ... }
    sub set_weight { ... }

=end programlisting

E<hellip>и:

=begin programlisting

    sub make_accessors { ... }

    BEGIN
    {
        for my $accessor (qw( age name weight ))
        {
            my ($get, $set) =
                make_accessors( $accessor );

            no strict 'refs';
            *{ 'get_' . $accessor } = $get;
            *{ 'set_' . $accessor } = $set;
        }
    }

=end programlisting

E<hellip>преимущественно в поддерживаемости.

X<C<BEGIN>; implicit>
X<modules; implicit C<BEGIN>>

Внутри модуля, любой код за пределами функций выполняется, когда вы используете
его посредством C<use>, из-за неявного C<BEGIN>, который Perl добавляет вокруг
C<require> и C<import> (L<importing>). Любой код за пределами функций, но внутри
модуля, будет выполнен I<перед> тем, как произойдёт вызов C<import()>. Если вы
загружаете модуль с помощью I<require>, неявного блока C<BEGIN> не будет.
Выполнение кода за пределами функций произойдёт в I<конце> парсинга.

Учитывайте взаимодействие между лексическими I<объявлениями> (ассоциирование
имени с областью видимости) и лексическими I<присваиваниями>. Первые происходят
во время компиляции, тогда как последние происходят в точке выполнения. Этот код
имеет неочевидный баг:

X<CPAN; C<UNIVERSAL::require>>

=begin programlisting

    # добавляет метод require() в UNIVERSAL
    use UNIVERSAL::require;

    # ведёт к ошибкам; не использовать
    my $wanted_package = 'Monkey::Jetpack';

    BEGIN
    {
        $wanted_package->require();
        $wanted_package->import();
    }

=end programlisting

E<hellip>потому что блок C<BEGIN> будет выпволнен I<перед> тем, как произойдёт
присваивание строкового значения C<$wanted_package>. Результатом будет
исключение из-за попытки вызвать метод C<require()> на неопределённом значении.

=head2 Class::MOP

Z<class_mop>

X<C<Class::MOP>>
X<Moose>
X<objects; meta object protocol>
X<meta object protocol>

В отличие от установки ссылок на функции для заполнения пространств имён и
создания методов, в Perl 5 нет простого способа программного создания классов.
На помощь приходит Moose с входящей в него библиотекой C<Class::MOP>. Она
предоставляет I<протокол метаобъектов> E<mdash> механизм для создания и
манипулирования объектной системой в терминах её самой.

Вместо написания своего собственного хрупкого кода со строковым C<eval> или
попыток вручную ковыряться в таблицах символов, вы можете манипулировать
сущностями и абстракциями вашей программы с помощью объектов и методов:

Так создаётся класс:

=begin programlisting

    use Class::MOP;

    my $class = Class::MOP::Class->create(
                    'Monkey::Wrench'
                );

=end programlisting

X<metaclass>
X<OO; metaclass>

Добавьте атрибуты и методы в этот класс, когда создадите его:

=begin programlisting

    my $class = Class::MOP::Class->create(
        'Monkey::Wrench' =>
        (
            attributes =>
            [
                Class::MOP::Attribute->new('$material'),
                Class::MOP::Attribute->new('$color'),
            ]
            methods =>
            {
                tighten => sub { ... },
                loosen  => sub { ... },
            }
        ),
    );

=end programlisting

E<hellip>или в метакласс (объект, представляющий этот класс), когда он будет
создан:

=begin programlisting

    $class->add_attribute(
        experience  => Class::MOP::Attribute->new('$xp')
    );

    $class->add_method( bash_zombie => sub { ... } );

=end programlisting

E<hellip>и вы можете инспектировать метакласс:

=begin programlisting

    my @attrs = $class->get_all_attributes();
    my @meths = $class->get_all_methods();

=end programlisting

X<CPAN; C<Class::MOP::Attribute>>
X<CPAN; C<Class::MOP::Method>>

Аналогично, C<Class::MOP::Attribute> и C<Class::MOP::Method> позволяют вам
создавать, манипулировать и анализировать атрибуты и методы.
