=head1 Вложенные структуры данных

Z<nested_data_structures>
X<data structures>
X<nested data structures>

Агрегатные типы данных Perl E<mdash> массивы и хеши E<mdash> позволяют вам
хранить скаляры, индексированные целыми числами или строковыми ключами. Ссылки в
Perl 5 позволяют получать доступ к агрегатным типам данных через специальные
скаляры. Вложенные структуры данных в Perl, такие как массив массивов или хеш
хешей, становятся возможными благодаря использованию ссылок.

Для объявления вложенной структуры данных используйте синтаксис объявления
анонимной ссылки:

=begin programlisting

    my @famous_triplets = (
        [qw( eenie miney moe   )],
        [qw( huey  dewey louie )],
        [qw( duck  duck  goose )],
    );

    my %meals = (
        breakfast => { entree => 'eggs',
                       side   => 'hash browns' },
        lunch     => { entree => 'panini',
                       side   => 'apple'         },
        dinner    => { entree => 'steak',
                       side   => 'avocado salad' },
    );

=end programlisting

=begin tip Запятые E<mdash> бесплатно

Perl позволяет, хотя и не требует, ставить завершающую запятую для облегчения
последующего добавления элементов в список.

=end tip

Для доступа к элементам вложенных структур данных используйте синтаксис ссылок
Perl. Сигил обозначает количество данные, которое должно быть получено, а
разыменовывающая стрелка указывает, что значение части структуры данных является
ссылкой:

=begin programlisting

    my $last_nephew = $famous_triplets[1]->[2];
    my $breaky_side = $meals{breakfast}->{side};

=end programlisting

Единственный способ создать многоуровневую структура данных E<mdash> посредством
ссылок, так что стрелка излишня. Вы можете опустить её для ясности, за
исключением вызовов функций по ссылке:

=begin programlisting

    my $nephew = $famous_triplets[1][2];
    my $meal   = $meals{breakfast}{side};
    $actions{financial}{buy_food}->( $nephew, $meal );

=end programlisting

Используйте устраняющий неоднозначность блок для доступа к компонентам вложенной
структуры данных, как если бы они были массивами или хешами первого класса:

=begin programlisting

    my $nephew_count   = @{ $famous_triplets[1] };
    my $dinner_courses = keys %{ $meals{dinner} };

=end programlisting

E<mdash>или для получения среза вложенной структуры данных:

=begin programlisting

    my ($entree, $side) = @{ $meals{breakfast} }
                           {qw( entree side )};

=end programlisting

Пробелы помогают, но не полностью устраняют зашумлённость этой конструкции.
Используйте временные переменные для придания ясности:

=begin programlisting

    my $meal_ref        = $meals{breakfast};
    my ($entree, $side) = @$meal_ref{qw( entree side )};

=end programlisting

X<aliasing>

E<hellip>или используйте неявное создание псевдонимов в C<$_> директивой C<for>,
чтобы избежать использования промежуточной ссылки:

=begin programlisting

    my ($entree, $side) = @{ $_ }{qw( entree side )}
                          for $meals{breakfast};

=end programlisting

C<perldoc perldsc>, кулинарная книга структур данных, даёт обширные примеры
того, как использовать разные структуры данных в Perl.

=head2 Автовивификация

Z<autovivification>
X<autovivification>

Когда вы пытаетесь записать значение в компонент вложенной структуры данных,
Perl по необходимости создаёт путь через структуру данных до пункта назначения:

=begin programlisting

    my @aoaoaoa;
    $aoaoaoa[0][0][0][0] = 'nested deeply';

=end programlisting

После второй строки кода этот массив массивов массивов массивов содержит ссылку
на массив в ссылке на массив в ссылке на массив в ссылке на массив. Каждая
ссылка содержит один элемент. Аналогично, обработка неопределённого значения
так, как будто это ссылка на хеш во вложенной структуре данных, сделает его
таковой:

=begin programlisting

    my %hohoh;
    $hohoh{Robot}{Santa} = 'mostly harmful';

=end programlisting

X<autovivification>
X<C<autovivification> pragma>
X<pragmas; C<autovivification>>

Это полезное поведение называется I<автовивификацией>. Оно уменьшает объём
инициализирующего кода вложенной стркутуры данных, но не может определить
разницу между честным намерением создать недостающие элементы во вложенной
структуре данных и опечаткой. Прагма C<autovivification> (L<pragmas>) из CPAN
позволит вам отключить автовивификацию в лексической области видимости для
определённых типов операций.

Вас может удивить применение преимуществ автовивификации параллельно установке
ограничений с помощью C<strict>. Это вопрос баланса. Будет ли более удобным
получить ошибки, изменяющие поведение вашей программы, ценой отключения проверок
на ошибки для хорошо инкапсулированных символьных ссылок? Будет ли более удобным
позволить структурам данных расти вместо чёткого указания их размера и
доступных ключей?

Ответы зависят от вашего проекта. Во период начальной разработки позвольте себе
свободу экспериментировать. Во время тестирования и развёртывания рассмотрите
увеличение строгости для предотвращения нежелательных побочных эффектов.
Благодаря лексической области видимости прагм C<strict> и C<autovivification> вы
можете включить эти варианты поведения там, где это необходимо.

Вы I<можете> проверять свои ожидания перед разыменованием каждого уровня сложной
структуры данных, но результирующий код зачастую будет длинным и громоздким.
Лучше избегать глубоко вложенных структур данных, пересмотрев свою модель данных
в сторону лучшей инкапсуляции.

=head2 Отладка вложенных структур данных

Сложность разыменовывающего синтаксиса Perl 5, объединённая с потенциальной
путаницей нескольких уровней ссылок, может сделать отладку вложенных структур
данных сложной. Есть два хороших инструмента визуализации.

X<C<Data::Dumper>>

Встроенный модуль C<Data::Dumper> преобразует значения произвольной сложности в
строки кода Perl 5:

=begin programlisting

    use Data::Dumper;

    print Dumper( $my_complex_structure );

=end programlisting

Это удобно для определения того, что содержит структура данных, что вы должны
получить, и что вы получили вместо этого. C<Data::Dumper> может выводить
объекты, так же как ссылки на функции (если вы установите
C<$Data::Dumper::Deparse> в истинное значение).

Хотя C<Data::Dumper> E<mdash> встроенный модуль и выводит код на Perl 5, его
вывод довольно многословен. Некоторые разработчики предпочитают использовать для
отладки модули C<YAML::XS> или C<JSON>. Они не выдают код на Perl 5, но их вывод
может быть гораздо проще для чтения и понимания.

=head2 Циклические ссылки

Z<circular_references>

X<circular references>
X<memory management; circular references>
X<garbage collection>

Имеющаяся в Perl 5 система управления памятью с помощью подсчёта ссылок
(L<reference_counts>) имеет один недостаток, заметный для пользовательского
кода. Две ссылки, которые в конечном счёте указывают друг на друга, образуют
I<циклическую ссылку>, которую Perl не может уничтожить сам. Рассмотрим
биологическую модель, где каждая сущность имеет двух родителей и ноль или больше
детей:

=begin programlisting

    my $alice  = { mother => '',     father => ''      };
    my $robert = { mother => '',     father => ''      };
    my $cianne = { mother => $alice, father => $robert };

    push @{ $alice->{children}  }, $cianne;
    push @{ $robert->{children} }, $cianne;

=end programlisting

И C<$alice>, и C<$robert> содержат ссылку на массив, которая содержит
C<$cianne>. Поскольку C<$cianne> E<mdash> ссылка на хеш, которая содержит
C<$alice> и C<$robert>, Perl никогда не сможет уменьшить счётчик ссылок любого
из этих трёх человек до нуля. Он не распознает, что эти циклические ссылки
существуют, и не сможет управлять сроком жизни этих сущностей.

X<references; weak>
X<weak references>
X<C<Scalar::Util>>

Или разбейте счётчик ссылок сами вручную (очистив детей C<$alice> и C<$robert>
или родителей C<$cianne>), или используйте I<слабые ссылки>. Слабая ссылка
E<mdash> это ссылка, которая не увеличивает счётчик ссылок значения, на которое
ссылается. Слабые ссылки доступны во встроенном модуле C<Scalar::Util>. Его
функция C<weaken()> предотвращает увеличение счётчика ссылок:

=begin programlisting

    use Scalar::Util 'weaken';

    my $alice  = { mother => '',     father => ''      };
    my $robert = { mother => '',     father => ''      };
    my $cianne = { mother => $alice, father => $robert };

    push @{ $alice->{children}  }, $cianne;
    push @{ $robert->{children} }, $cianne;

    B<< weaken( $cianne->{mother} ); >>
    B<< weaken( $cianne->{father} ); >>

=end programlisting

Теперь C<$cianne> сохранит ссылки на C<$alice> и C<$robert>, но эти ссылки сами
по себе не будут удерживать сборщик мусора Perl от разрушения этих структур
данных. Большинство структур данных не требуют слабых ссылок, но когда они
необходимы E<mdash> они бесценны.

=head2 Альтернативы вложенным структурам данных

Хотя Perl способен обрабатывать структуры данных, вложенные так глубоко, как
нужно, человеческая стоимость понимания этих структур данных и их
взаимоотношений E<mdash> не говоря о сложном синтаксисе E<mdash> высока. После
двух или трёх уровней вложенности задумайтесь, не позволит ли вам моделирование
разных компонентов вашей системы как классов и объектов (L<moose>) сделать код
чище.
