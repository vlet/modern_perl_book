=head1 Имена

Z<names>

X<names>
X<identifiers>

I<Имена> (или I<идентификаторы>) в программах на Perl повсюду: переменные,
функции, пакеты, классы и даже дескрипторы файлов. Все эти имена начинаются с
буквы или знака подчёркивания и могут включать любую комбинацию букв, цифр и
знаков подчёркивания. Если задействована прагма C<utf8> (L<unicode>), вы можете
использовать в идентификаторах любые словарные символы UTF-8. Всё это допустимые
в Perl идентификаторы:

=begin programlisting

    my $name;
    my @_private_names;
    my %Names_to_Addresses;

    sub anAwkwardName3;

    # с включенным use utf8;
    package Ingy::DE<ouml>t::Net;

=end programlisting

Такие идентификаторы недопустимы в Perl:

=begin programlisting

    my $invalid name;
    my @3;
    my %~flags;

    package a-lisp-style-name;

=end programlisting

X<symbolic lookups>

I<Имена существуют в первую очередь для пользы программиста>. Эти правила
применяются только к именам литералов, которые появляются в вашем исходном коде
E<laquo>как естьE<raquo>, таким как C<sub fetch_pie> или C<my $waffleiron>.
Только парсер Perl принуждает следовать правилам об именах идентификаторов.

Динамическая натура Perl позволяет вам ссылаться на сущности с помощью имён,
генерируемых во время исполнения или указанных как входные данные программы. Этот
I<символьный поиск> обеспечивает гибкость ценой некоторого ущерба безопасности.
В частности, непрямой вызов функций или методов или поиск символов в
пространстве имён позволяет вам обойти парсер Perl.

Такое поведение может привести к запутанному коду. Как эффективно рекомендует
Марк Джейсон Доминус (Mark Jason
Dominus)N<U<http://perl.plover.com/varvarname.html>>, лучше используйте хеши или
вложенные структуры данных (L<nested_data_structures>).

=head2 Имена переменных и сигилы

X<variables; names>
X<scalar variables>
X<variables; scalars>
X<scalars>
X<arrays>
X<variables; arrays>
X<hashes>
X<variables; hashes>
X<sigil>

I<Имена переменных> всегда имеют предшествующий I<сигил> (или символ), который
обозначает тип значения переменной. I<Скалярные переменные> (L<scalars>)
используют знак доллара (C<$>). I<Переменные-массивы> (L<arrays>) используют
знак E<laquo>atE<raquo> (E<laquo>собакаE<raquo>), (C<@>). I<Переменные-хеши>
(L<hashes>) используют знак процента (C<%>):

=begin programlisting

    my $scalar;
    my @array;
    my %hash;

=end programlisting

Эти сигилы обеспечивают визуальное разделение пространств имён для имён
переменных. Возможно E<mdash> хотя это и может привести к путанице E<mdash>
объявить несколько переменных с одним и тем же именем, но разными типами:

=begin programlisting

    my ($bad_name, @bad_name, %bad_name);

=end programlisting

Хотя Perl и не будет сбит с толку, люди, читающие этот код, будут.

X<variant sigils>

Сигилы Perl 5 E<mdash> I<варьирующиеся сигилы>. Как контекст определяет, сколько
элементов вы ожидаете от операции, или какого типа данные вы ожидаете получить,
так и сигил определяет, как вы манипулируете данными переменной. Например, для
доступа к единственному элементу массива или хеша вы должны использовать сигил
скаляра (C<$>):

=begin programlisting

    my $hash_element  = $hash{ $key };
    my $array_element = $array[ $index ]

    $hash{ $key }     = 'value';
    $array[ $index ]  = 'item';

=end programlisting

X<lvalue>
X<rvalue>

Параллель с контекстом количества важна. Использование скалярного элемента
структуры как I<lvalue>, левого значения (цель присвоения, находящаяся слева от
знака C<=>), налагает скалярный контекст (L<context_philosophy>) на I<rvalue>,
правое значение (присваемое значение, находящееся справа от знака C<=>).

X<slices>

Аналогично, доступ к нескольким элементам хеша или массива E<mdash> операция,
известная как I<получение среза> E<mdash> использует символ C<@> и
налагает списочный контекстN<E<hellip>даже если сам список содержит ноль или
один элемент>:

=begin programlisting

    my @hash_elements  = @hash{ @keys };
    my @array_elements = @array[ @indexes ];

    my %hash;
    @hash{ @keys }     = @values;

=end programlisting

Наиболее надёжный способ определить тип переменной E<mdash> скаляр, массив или
хеш E<mdash> обратить внимание на производимые с ней операции. Скаляры
поддерживают все базовые операции, такие как строковые, числовые и булевы
манипуляции. Массивы поддерживают доступ по индексу посредством квадратных
скобок. Хеши поддерживают доступ по ключу посредством фигурных скобок.

=head2 Пространства имён

X<fully-qualified name>
X<namespaces>

Perl предоставляет механизм группировки сходных функций и переменных в их
собственные уникальные именованные пространства E<mdash> I<пространства имён>
(L<packages>). Пространство имён E<mdash> это именованная коллекция символов.
Perl позволяет использование многоуровневых пространств имён, с именами,
соединёнными двойным двоеточием (C<::>), где C<DessertShop::IceCream> ссылается
на логическую коллекцию родственных переменных и функций, таких как C<scoop()>
и C<pour_hot_fudge()>.

Внутри пространства имён вы можете использовать короткие имена его членов.
Снаружи пространства имён ссылайтесь на его член, используя его I<полностью
определённое имя>. Таким образом, C<add_sprinkles()> внутри
C<DessertShop::IceCream> ссылается на ту же самую функцию, что и
C<DessertShop::IceCream::add_sprinkles()> снаружи пространства имён.

Хотя к именам пакетов применимы стандартные правила именования, по соглашению
имена определённых пользователями пакетов начинаются с заглавных букв. Ядро Perl
резервирует строчные имена пакетов для прагм ядра (L<pragmas>), таких как
C<strict> и C<warnings>. Эта политика закреплена в первую очередь рекомендациями
сообщества.

Все пространства имён в Perl 5 глобально видимы. Когда Perl ищет символ в
C<DessertShop::IceCream::Freezer>, он ищет в символьной таблице C<main::>
символ, представляющий пространство имён C<DessertShop::>, затем в нём E<mdash>
пространство имён C<IceCream::>, и так далее. C<Freezer::> видим снаружи
пространства имён C<IceCream::>. Вложенность одного в другое E<mdash> всего лишь
механизм хранения, и ничего не говорит об отношениях между родительскими и
дочерними пакетами, или пакетами, находящимися на одном уровне. Только
программист может сделать I<логические> отношения между сущностями очевидными
E<mdash> выбрав хорошие имена и правильно их организовав.
