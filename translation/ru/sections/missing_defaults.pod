=head1 Недостающие умолчания

Z<missing_defaults>

Дизайн-процесс Perl 5 пытается предугадать новые направляения для языка, но в
1994 году невозможно было предсказать будущее таким, каким оно будет в 2011
году. Perl 5 расширил язык, но остался совместим с Perl 1 из 1987 года.

Лучший код на Perl 5 в 2011 году очень сильно отличается от лучшего кода на
Perl 5 в 1994 году, или лучшего кода на Perl 1 в 1987 году.

X<CPAN; C<Task::Kensho>>

Хотя Perl 5 содержит огромную встроенную библиотеку, он не всеобъемлющ.
Многие из лучших модулей Perl 5 существуют в CPAN (L<cpan>) а не в ядре.
Метадистрибутив C<Task::Kensho> включает несколько других дистрибутивов, которые
представляют собой лучшее из того, что может предложить CPAN. Если вам нужно
решить задачу, загляните сначала туда.

С учётом вышесказанного, несколько встроенных прагм и модулей незаменимы для
серьёзных Perl-программистов.

=head2 Прагма strict

X<C<strict>>
X<pragmas; C<strict>>

Прагма C<strict> (L<pragmas>) позволяет вам запретить (или вновь разрешить)
разные мощные языковые конструкции, создающие потенциальную возможность
непреднамеренных ошибок.

C<strict> запрещает символические ссылки, требует объявления переменных
(L<lexical_scope>) и запрещает использование необъявленных голых слов
(L<barewords>). Тогда как редкое использование символических ссылок необходимо
для манипулирования таблицааи символов (L<import>), использование переменной
как имени переменной создаёт вероятность неочевидных ошибок действия на
расстоянии E<mdash> или, хуже, возможность для плохо-валидированного
пользовательского ввода манипулировать внутренними данными со злонамеренными
целями.

Требование объявлений переменных помогает определить опечатки в именах
переменных и поощряет соответствующие области видимости лексических переменных.
Намного проще видеть намеренную область видимости лексической переменной если
все переменные имеют объявления C<my> или C<our> в соответствующей области
видимости.

C<strict> имеет лексическое действие, основанное на области видимости времени
компиляции её использования (L<import>) и отключения (с помощью C<no>). Смотрите
C<perldoc strict> для больших подробностей.

=head2 Прагма warnings

Прагма C<warnings> (L<handling_warnings>) контролирует сообщения о разных
классах предупреждений в Perl 5, таких как попытка преобразовать в строку
значение C<undef> или использование неверного типа оператора для значений. Она
также предупреждает об использовании нерекомендуемых возможностей.

Наиболее полезные предупреждения объясняют, что Perl имеет сложности с
пониманием того, что вы имели ввиду, и вынужден угадывать соответствующую
интерпретацию. Даже несмотря на то, что Perl зачастую угадывает корректно,
устранение неоднозначности с вашей стороны приведёт к уверенности, что программа
работает корректно.

Прагма C<warnings> имеет лексическое действие в области видимости времени
компиляции её использования или отключения (с помощью C<no>). Смотрите C<perldoc
perllexwarn> и C<perldoc warnings> для больших подробностей.

=begin tip Попросить больше помощи

Объедините C<use warnings> с C<use diagnostics> чтобы получить расширенные
диагностические сообщения для каждого предупреждения, присутствующего в вашей
программе. Эта расширенная диагностика поступает из C<perldoc perldiag>. Это
поведение полезно при изучении Perl. Отключите его перед внедрением вашей
программы, потому что оно производит многословный вывод, который может заполнить
ваши логи и показать слишком много информации пользователям.

=end tip

=head2 C<IO::File> и C<IO::Handle>

X<C<IO::File>>
X<C<IO::Handle>>

До Perl 5.14 лексические дескрипторы файлов были объектами класса C<IO::Handle>,
но вам требовалось явно загрузить C<IO::Handle> прежде чем вы могли вызывать на
них методы. С Perl 5.14 лексические дескрипторы файлов E<mdash> экземпляры
C<IO::File> и Perl загружает C<IO::File> за вас.

Добавьте C<IO::Handle> в код, запускающийся на Perl 5.12 или раньше если вы
вызываете методы на лексических дескрипторах файлов.

=head2 Прагма autodie

Z<autodie>
X<C<autodie> pragma>
X<pragmas; C<autodie>>

Perl 5 оставляет обработку ошибок (или игнорирование ошибок) вам. Если вы не
достаточно внимательны, чтобы проверять, например, возвращаемое значение каждого
вызова C<open()>, вы можете попытаться прочитать из закрытого дескриптора файла
E<mdash> или хуже, потерять данные при попытке записать в него. Прагма
C<autodie> изменяет поведение по умолчанию. Если вы напишете:

=begin programlisting

    use autodie;

    open my $fh, '>', $file;

=end programlisting

E<hellip>неудачный вызов C<open()> выбросит исключение. Учитывая, что наиболее
подходящий подход для неудавшегося системного вызова E<mdash> выбросить
исключение, эта прагма может удалить много шаблонного кода и подарить вам
душевное спокойствие от знания того, что вы не забыли проверить возвращаемое
значение.

Эта прагма появилась в ядре Perl 5 с Perl 5.10.1. Смотрите C<perldoc autodie>
для большей информации.
