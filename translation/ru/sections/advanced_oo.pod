=head1 Продвинутое ОО в Perl

Z<advanced_oo>

Создание и использование объектов в Perl 5 с Moose (L<moose>) легко.
I<Проектирование> хороших программ E<mdash> нет. Вы должны выдерживать баланс
между проектированием слишком много и слишком мало. Только практический опыт
может помочь вам понять наиболее важные техники проектирования, но несколько
принципов могут указать вам направление.

=head2 Предпочитайте компоновку наследованию

X<OO: composition>
X<OO; inheritance>

Новички в ОО-проектировании зачастую чрезмерно применяют наследование для
повторного использования кода и применения полиморфизма. Результат этого
E<mdash> глубокая иерархия классов с ответственностями, разбросанными по
неверным местам. Поддержка этого кода тяжела E<mdash> кто знает, где добавить
или отредактировать поведение? Что случится, если код в одном месте конфликтует
с кодом, объявленным где-то ещё?

X<OO; is-a>
X<OO; has-a>

Наследование E<mdash> лишь один из многих инструментов. C<Car> может расширять
C<Vehicle::Wheeled> (I<отношение is-a>, I<является>), но лучше, если C<Car>
будет I<содержать> несколько объектов C<Wheel> в качестве атрибутов экземпляра
(I<отношение has-a>, I<имеет>).

Разбиение сложных классов на меньшие, специализированные сущности (будь то
классы или роли) улучшает инкапсуляцию и уменьшает возможность того, что
какой-либо класс или роль слишком разрастётся. Меньшие, более простые и лучше
инкапсулированные сущности проще для понимания и поддержки.

=head2 Принцип единственной обязанности

X<OO; single responsibility principle>

Когда вы проектируете вашу объектную систему, обдумайте обязанности каждой
сущности. Например, объект C<Employee> может представлять индивидуальную
информацию об имени человека, контактную информацию и другие личные данные, а
объект C<Job> может представлять рабочие обязанности. Разделение этих сущностей
в по их обязанностям позволяет классу C<Employee> принимать во внимание только
проблему управления информацией, касающейся того, кто человек есть, а классу
C<Job> E<mdash> представлять, что человек делает. (Например, два сотрудника
C<Employee> могут иметь договорённость по разделению одной работы C<Job>.)

Если каждый класс имеет единственную обязанность, вы улучшаете инкапсуляцию
свойственных классу данных и поведения и уменьшаете пересечения между классами.

=head2 Не повторяйтесь

X<DRY>

Сложность и дублирование затрудняют разработку и поддержку. Принцип DRY (Don't
Repeat Yourself, Не повторяйтесь) E<mdash> напоминание о необходимости находить
и устранять дублирование внутри системы. Дублирование существует в данных, так
же как и в коде. Вместо повторения конфигурационной информации, пользовательских
данных и других артефактов внутри вашей системы, создаёте единое, каноническое
представление этой информации, из которого вы сможете генерировать другие
артефакты.

Этот принцип помогает уменьшить возможность того, что важные части вашей системы
могут потерять синхронизированность, и также помогает найти оптимальное
представление системы и её данных.

=head2 Принцип замещения Лисков

X<OO; Liskov Substitution Principle>

Принцип замещения Лисков предполагает, что вы должны иметь возможность поставить
специализацию класса или роли на место оригинала, не нарушив API оригинала.
Другими словами, объект должен быть также или более общим в отношении того,
что он ожидает, и как минимум так же конкретнет в отношении того, что он
производит.

Представьте два класса, C<Dessert> и его дочерний класс C<PecanPie>. Если классы
следуют принципу замещения Лисков, вы можете заменить в наборе тестов каждое
использование объектов C<Dessert> объектами C<PecanPie>, и все тесты должны
пройтиN<См. E<laquo>IS-STRICTLY-EQUIVALENT-TO-A<raquo> Рэга Брейтуейта (Reg
Braithwaite) для дальнейших подробностей,
U<http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html>.>.

=head2 Подтипы и приведение типов

Z<subtypes>
Z<coercions>
X<types>
X<subtypes>
X<coercion>

Moose позволяет вам объявить и использовать типы, а также расширять их с помощью
подтипов, для формирования наиболее специализированного описания того, что
представляют собой ваши данные и как они себя ведут. Эти прояснения типов
помогают проверить, что данные, с которыми вы собираетесь работать в конкретных
функциях и методах, соответствующи, и даже указать механизмы преобразования
данных одного типа в данные другого типа.

X<C<Moose::Util::TypeConstraints>>
X<C<MooseX::Types>>

See C<Moose::Util::TypeConstraints> and C<MooseX::Types> for more information.

=head2 Неизменяемость

Z<immutability>

X<OO; immutability>

Новички в ОО зачастую обращаются с объектами так, как будто они пачка записей,
использующих методы для получения и установки внутренних значений. Эта простая
техника ведёт к неприятному соблазну распространить обязанности объекта по всей
системе.

В случае хорошо спроектированного объекта, вы говорите ему, что делать, но не
как это делать. Как правило большого пальца, если обнаружили, что обращаетесь к
данным экземпляра объекта (даже с помощью методов-аксессоров), у вас, возможно,
слишком много доступа к внутренностям объекта.

Один из подходов, предотвращающих такое поведение E<mdash> считать объект
неизменяемым. Передайте нужные данные в их конструкторы, а затем запретите
любые модификации этой информации из-за пределов класса. Не делайте видимыми
методы изменения данных экземпляра. Сконструированные таким образом объекты
всегда корректны с момент своего создания и не могут стать некорректными в
результате внешних манипуляций. Для достижения этого требуется огромная
дисциплина, но получающиеся в результате системы надёжны, легко тестируются и
поддерживаются.

Некоторые варианты проектирования заходят так далеко, что запрещают изменение
данных экземпляра I<внутри> самого класса, хотя этого достичь гораздо труднее.
