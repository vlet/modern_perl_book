=head1 Типы операторов

Z<operator_types>

Оперторы Perl предоставляют контекст значения (L<value_contexts>) своим
операндам. Чтобы выбрать подходящий оператор, нужно понимать значения
предоставляемых вами операндов, а так же значение, которое вы ожидаете получить.

=head2 Числовые операторы

Z<numeric_operators>

X<operators; numeric>
X<operators; arithmetic>
X<operators; C<+>>
X<C<+>; numeric operator>
X<operators; C<->>
X<C<->; numeric operator>
X<operators; C<*>>
X<C<*>; numeric operator>
X<operators; C</>>
X<C</>; numeric operator>
X<operators; C<**>>
X<C<**>; numeric operator>
X<operators; C<%>>
X<C<%>; numeric operator>
X<operators; C<+=>>
X<C<+=>; numeric operator>
X<operators; C<-=>>
X<C<-=>; numeric operator>
X<operators; C<*=>>
X<C<*=>; numeric operator>
X<operators; C</=>>
X<C</=>; numeric operator>
X<operators; C<**=>>
X<C<**=>; numeric operator>
X<operators; C<%=>>
X<C<%=>; numeric operator>
X<operators; C<-->>
X<C<-->; numeric operator>

Числовые операторы налагают числовой контекст на свои операнды. Эти операторы
E<mdash> стандартные арифметические операторы, такие как сложение (C<+>),
вычитание (C<->), умножение (C<*>), деление (C</>), возведение в степерь
(C<**>), остаток от деления (C<%>), их вариации (C<+=>, C<-=>, C<*=>, C</=>,
C<**=> и C<%=>), а также постфиксный и префиксный автодекремент (C<-->).

Оператор автоинкремента имеет специальное строковое поведение
(L<auto_increment_operator>).

X<operators; C<==>>
X<operators; C<!=>>
X<<< operators; C<< E<lt> >> >>>
X<<< operators; C<< E<gt> >> >>>
X<<< operators; C<< E<lt>= >> >>>
X<<< operators; C<< E<gt>= >> >>>
X<<< operators; C<< E<lt>=E<gt> >> >>>

X<C<!=>; numeric comparison operator>
X<C<==>; numeric comparison operator>
X<<< C<< E<gt> >>; numeric comparison operator >>>
X<<< C<< E<lt> >>; numeric comparison operator >>>
X<<< C<< E<gt>= >>; numeric comparison operator >>>
X<<< C<< E<lt>= >>; numeric comparison operator >>>
X<<< C<< E<lt>=E<gt> >>; numeric comparison operator >>>

Некоторые операторы сравнения налагают числовой контекст на свои операнды. Это
числовое равенство (C<==>), числовое неравенство (C<!=>), больше чем
(C<< E<gt> >>), меньше чем (C<< E<lt> >>), больше или равно (C<< E<gt>= >>),
меньше или равно (C<< E<lt>= >>) и оператор сравнения (C<< E<lt>=E<gt> >>).

=head2 Строковые операторы

X<operators; string>
X<strings; operators>
X<operators; C<=~>>
X<C<=~>; string operator>
X<operators; C<!~>>
X<C<!~>; string operator>
X<operators; C<.>>
X<C<.>; string operator>

Строковые операторы налагают строковый контекст на свои операнды. Это
положительная и отрицательная связь с регулярными выражениями (C<=~> and C<!~>
соответственно) и конкатенация (C<.>).

X<operators; C<eq>>
X<operators; C<ne>>
X<operators; C<gt>>
X<operators; C<lt>>
X<operators; C<ge>>
X<operators; C<le>>
X<operators; C<cmp>>
X<C<eq>; string comparison operator>
X<C<ne>; string comparison operator>
X<C<gt>; string comparison operator>
X<C<lt>; string comparison operator>
X<C<ge>; string comparison operator>
X<C<le>; string comparison operator>
X<C<cmp>; string comparison operator>

Некоторые операторы сравнения налагают строковый контекст на свои операнды. Это
строковое равенство (C<eq>), строковое неравенство (C<ne>), больше чем (C<gt>),
меньше чем (C<lt>), больше или равно (C<ge>), меньше или равно (C<le>) и
оператор строкового сравнения (C<cmp>).

=head2 Логические операторы

X<operators; logical>
X<operators; C<&&>>
X<operators; C<and>>
X<operators; C<||>>
X<operators; C<or>>
X<operators; C<//>>
X<operators; C<?:>>
X<operators; C<!>>
X<operators; C<not>>
X<operators; C<xor>>
X<C<&&>; logical operator>
X<C<and>; logical operator>
X<C<||>; logical operator>
X<C<or>; logical operator>
X<C<//>; logical operator>
X<C<?:>; logical operator>
X<C<!>; logical operator>
X<C<not>; logical operator>
X<C<xor>; logical operator>
X<operators; defined-or>
X<defined-or; logical operator>
X<short-circuiting>

Логические операторы налагают булев контекст на свои операнды. Это операторы
C<&&>, C<and>, C<||> и C<or>. Все они инфиксные и проявляют поведение
I<короткого замыкания> (L<short_circuiting>). Словесные варианты имеют более
низкий приоритет, чем их знаковые формы.

Оператор определено-или, C<//>, проверяет I<определённость> своего операнда. В
отличие от C<||>, который проверяет I<истинность> своего операнда, C<//>
возвращает истинное значение даже если его операнд вычисляется в числовой ноль
или пустую строку. Это особенно полезно для установки параметров по умолчанию:

=begin programlisting

    sub name_pet
    {
        my $name = shift // 'Fluffy';
        ...
    }

=end programlisting

X<C<?:>; ternary conditional operator>

Тернарный условный оператор (C<?:>) принимает три операнда. Он вычисляет первый
операнд в булевом контексте и возвращает второй операнд, если первый E<mdash>
истина, или третий в противном случае:

=begin programlisting

    my $truthiness = $value ? 'true' : 'false';

=end programlisting

Префиксные операторы C<!> и C<not> возвращают логическую противоположность
булева значения своих операндов. C<not> имеет более низкий приоритет, чем C<!>.

Оператор C<xor> E<mdash> инфиксный оператор, вычисляющий исключающее или своих
операндов.

=head2 Побитовые операторы

X<operators; bitwise>
X<<< operators; C<< E<lt>E<lt> >> >>>
X<<< operators; C<< E<gt>E<gt> >> >>>
X<operators; C<&>>
X<operators; C<|>>
X<operators; C<^>>
X<operators; C<&=>>
X<operators; C<|=>>
X<operators; C<^=>>
X<<< operators; C<< E<lt>E<lt>= >> >>>
X<<< operators; C<< E<gt>E<gt>= >> >>>

X<<< C<< E<lt>E<lt> >>; bitwise operator >>>
X<<< C<< E<gt>E<gt> >>; bitwise operator >>>

X<C<&>; bitwise operator>
X<C<|>; bitwise operator>
X<C<^>; bitwise operator>
X<C<&=>; bitwise operator>
X<C<|=>; bitwise operator>
X<C<^=>; bitwise operator>
X<<< C<< E<lt>E<lt>= >>; bitwise operator >>>
X<<< C<< E<gt>E<gt>= >>; bitwise operator >>>

Побитовые операторы обрабатывают свои операнды численно на битовом уровне. Эти
операторы не очень распространены. Они включают левый сдвиг (C<< << >>), правый
сдвиг (C<< >> >>), побитовое и (C<&>), побитовое или (C<|>) и побитовое
исключающее или (C<^>), а также их варианты (C<< <<= >>, C<< >>= >>, C<&=>,
C<|=> и C<^=>).

=head2 Специальные операторы

Z<auto_increment_operator>

X<operators; auto-increment>
X<auto-increment>
X<operators; C<++>>
X<C<++>; auto-increment operator>

Оператор автоинкремента имеет специальное поведение. При использовании на
значении с числовым компонентом (L<cached_coercions>), оператор инкрементирует
этот числовой компонент. Если значение очевидно строка (и не имеет числового
компонента), оператор инкрементирует это строковое значение так, что C<a>
становится C<b>, C<zz> становится C<aaa> и C<a9> становится C<b0>.

=begin programlisting

    my $num = 1;
    my $str = 'a';

    $num++;
    $str++;
    is( $num,   2, 'numeric autoincrement' );
    is( $str, 'b', 'string autoincrement'  );

    no warnings 'numeric';
    $num += $str;
    $str++;

    is( $num, 2, 'numeric addition with $str'    );
    is( $str, 1, '... gives $str a numeric part' );

=end programlisting

X<operators; repetition>
X<operators; C<x>>
X<C<x>; repetition operator>

Оператор повторения (C<x>) E<mdash> инфиксный оператор со сложным поведением. В
списочном контексте, когда передан список, он возвращает этот список,
повторённый количество раз, определяемое вторым операндом. В списочном контексте
если передан скаляр, он выдаёт строку, состояющую из строкового значения его
первого операнда, конкатенированного с собой количество раз, определяемое вторым
операндом.

В скалярном контексте операто всегда выдаёт конкатенированную строку,
соответствующим образом повторённую. Например:

=begin programlisting

    my @scheherazade = ('nights') x 1001;
    my $calendar     =  'nights'  x 1001;
    my $cal_length   =  length $calendar;

    is( @scheherazade, 1001, 'list repeated' );
    is( $cal_length,   1001 * length 'nights',
                       'word repeated' );

    my @schenolist   =  'nights'  x 1001;
    my $calscalar    = ('nights') x 1001;

    is( @schenolist, 1, 'no lvalue list' );
    is( length $calscalar,
        1001 * length 'nights', 'word still repeated' );

=end programlisting

X<operators; range>
X<range>
X<operators; C<..>>
X<C<..>; range operator>

Инфиксный оператор I<диапазона> (C<..>) генерирует список элементов в списочном
контексте:

=begin programlisting

    my @cards = ( 2 .. 10, 'J', 'Q', 'K', 'A' );

=end programlisting

Он может генерировать простые инкрементирующиеся диапазоны (как целочисленные,
так и строковые), но не может угадать шаблоны более сложных диапазонов.

X<operators; flip-flop>
X<flip-flop>
X<C<..>; flip-flop operator>

В булевом контексте оператор диапазона становится оператором I<flip-flop>. Этот
оператор выдаёт ложное значение до тех пор, пока его левый операнд E<mdash>
истина. Это значение остаётся истинным, пока правый оператор E<mdash> истина,
после чего вновь становится ложным, пока левый операнд снова не станет истинным.
Представьте разбор текста формального письма следующим образом:

=begin programlisting

    while (/Hello, $user/ .. /Sincerely,/)
    {
        say "> $_";
    }

=end programlisting

X<operators; comma>
X<operators; C<,>>
X<C<,>; operator>
X<<< operators; C<< =E<gt> >> >>>
X<<< C<< =E<gt> >>; fat comma operator >>>

Оператор I<запятая> (C<,>) E<mdash> инфиксный оператор. В скалярном контексте он
вычисляет свой левый операнд, а затем возвращает значение, полученное при
вычислении правого операнда. В списочном контексте он вычисляет оба операнда
в порядке слева направо.

Оператор толстой запятой (C<< => >>) кроме того автоматически берёт в кавычки
любое голое слово, использованное как его левый операнд (L<hashes>).
