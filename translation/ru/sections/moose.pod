=head1 Moose

Z<moose>

X<moose>

Стандартная объектная система Perl 5 гибка, но минималистична. Вы можете
построить замечательные вещи на её основе, но она даёт лишь небольшую помощь в
некоторых базовых задачах. I<Moose> E<mdash> это полноценная объектная система
для Perl5N<См. C<perldoc Moose::Manual> для подробной информации.>. Он
предоставляет простые умолчания и продвинутые возможности, заимствованные из
таких языков как Smalltalk, Common Lisp и Perl 6. Код Moose работает совместно
с стандартной объектной системой и на данный момент является лучшим способом
написания объектно-ориентированного кода в современном Perl 5.

=head2 Классы

X<classes>
X<builtins; C<package>>

Объект в Moose E<mdash> это конкретный экземпляр I<класса>, который представляет
собой шаблон, описывающий данные и поведение, характерные для объекта. Классы
используют пакеты (L<packages>) для создания пространств имён:

=begin programlisting

    package Cat
    {
        use Moose;
    }

=end programlisting

X<OO; instances>

Это класс C<Cat> I<выглядит> так, как будто ничего не делает, но это всё, что
нужно Moose для создания класса. Объекты (или I<экземпляры>) класса C<Cat>
создаются с помощью следующего синтаксиса:

=begin programlisting

    my $brad = Cat->new();
    my $jack = Cat->new();

=end programlisting

Как стрелка разыменовывает ссылку, также она и вызвает метод объекта или класса.

=head2 Методы

X<OO; methods>
X<OO; invocants>

I<Метод> E<mdash> это функция, ассоциированная с классом. Как функции
принадлежат пространствам имён, также и методы принадлежат классам, с двумя
отличиями. Во-первых, метод всегда оперирует I<вызывающей сущностью>. Вызов
C<new()> на C<Cat> в сущности отправляет классу C<Cat> сообщение. Имя класса,
C<Cat>, будет вызывающей сущностью C<new()>. Если вы вызываете метод на объекте,
этот объект будет вызывающей сущностью:

=begin programlisting

    my $choco = B<Cat>->new();
    B<$choco>->sleep_on_keyboard();

=end programlisting

X<dispatch>
X<method dispatch>
X<OO; dispatch>
X<OO; method dispatch>

Во-вторых, вызов метода всегда включает стратегию I<диспетчеризации>, когда
объектная система выбирает соответствующий метод. Учитывая простоту C<Cat>,
стратегия диспетчеризации очевидна, но существенная часть мощи ОО происходит из
этой идеи.

Внутри метода первым аргументом будет вызывающая сущность. Идиоматический Perl 5
использует C<$self> как его имя. Предположим, что <Cat> может мяукать:

=begin programlisting

    package Cat
    {
        use Moose;

        B<sub meow>
        B<{>
            B<my $self = shift;>
            B<say 'Meow!';>
        B<}>
    }

=end programlisting

Теперь все экземпляры C<Cat> могут разбудить вас с утра из-за того, что их ещё
не покормили:

=begin programlisting

    my $fuzzy_alarm = Cat->new();
    $fuzzy_alarm->meow() for 1 .. 3;

=end programlisting

X<class method>
X<instance method>
X<OO; class methods>
X<OO; instance methods>
X<methods; class>
X<methods; instance>

Методы, пользующиеся доступом к данным вызывающей сущностью E<mdash> это
I<методы экземпляра>, потому что для корректной работы они требуют присутствия
соответствующей вызывающей сущности. Методы (такие как C<meow()>), не
обращающиеся к данным экземпляра, E<mdash> это I<методы класса>. Вы можете
вызывать методы класса на классах и методы классов и экземпляров на экземплярах,
но нельзя вызывать методы экземпляра на классах.

X<methods; constructor>

I<Конструкторы>, которые I<создают> экземпляры, очевидно являются методами
класса. Moose предоставляет вам конструктор по умолчанию.

Методы класса E<mdash> это в сущности глобальные функции в пространстве имён.
Без доступа к данным экземпляра они имеют немного преимуществ над функциями в
пространстве имён. Большая часть ОО кода должным образом использует методы
экземпляров, так как у них есть доступ к данным экземпляра.

=head2 Атрибуты

X<attributes; objects>
X<OO; attributes>
X<OO; state>
X<attributes; typed>
X<attributes; C<ro> (read only)>

Каждй объект в Perl 5 уникален. Объекты могут содержать приватные данные,
ассоциированные с каждым объектом, E<mdash> это I<атрибуты>, I<данные
экземпляра>, или I<состояние> объекта. Определите атрибут, объявив его как часть
класса:

=begin programlisting

    package Cat
    {
        use Moose;

        B<< has 'name', is => 'ro', isa => 'Str'; >>
    }

=end programlisting

Это читается как E<laquo>Объекты C<Cat> имеют атрибут C<name>. Он доступен
только для чтения и является строкой.E<raquo>

Moose предоставляет функцию C<has()>, которая объявляет атрибут. Первый
аргумент, в данном случае C<'name'>, это имя атрибута. Пара аргументов
C<< is => 'ro' >> объявляет, что этот атрибут доступен только для чтения
(C<r>ead C<o>nly), так что вы не можете его изменять после того, как установили.
Наконец, пара C<< isa => 'Str' >> объявляет, что значение этого атрибута может
быть только строкой (C<str>ing).

X<methods; accessor>
X<OO; accessor methods>

Как результат выполнения C<has> Moose создает метод-I<аксессор> с именем
C<name()> и позволяет вам передавать параметр C<name> в конструктор класса
C<Cat>:

=begin programlisting

    for my $name (qw( Tuxie Petunia Daisy ))
    {
        my $cat = Cat->new( name => $name );
        say "Created a cat for ", $cat->name();
    }

=end programlisting

=begin sidebar

Документация Moose использует круглые скобки для разделения имён атрибутов и их
свойств:

=begin programlisting

        has 'name' => ( is => 'ro', isa => 'Str' );

=end programlisting

Это равнозначно следующему:

=begin programlisting

    has( 'name', 'is', 'ro', 'isa', 'Str' );

=end programlisting

Подход Moose хорошо подходит для сложных объявлений:

=begin programlisting

    has 'name' => (
        is         => 'ro',
        isa        => 'Str',

        # дополнительные параметры Moose; perldoc Moose
        init_arg   => undef,
        lazy_build => 1,
    );

=end programlisting

E<hellip>тогда как в этой книге предпочтение отдано подходу с меньшим
количеством пунктуации для простых объявлений. Выберите пунктуацию, которая
даёт вам наибольшую понятность.

=end sidebar

X<attributes; untyped>

Moose пожалуется, если вы передадите что-нибудь, не являющееся строкой. Атрибуты
не I<обязаны> иметь тип. В таком случае подойдёт что угодно:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        B<< has 'age',  is => 'ro'; >>
    }

    my $invalid = Cat->new( name => 'bizarre',
                            age  => 'purple' );

=end programlisting

Указание типа позволяет Moose выполнить для вас некоторую валидацию данных.
Иногда подобная строгость бесценна.

X<attributes; C<rw> (read-write)>
X<methods; mutator>
X<OO; mutator methods>

Если вы пометите атрибут как доступный для чтения I<и> записи (с помощью
C<< is => rw >>), Moose создаст метод-I<мутатор>, который может изменять
значение этого атрибута:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'age',  is => 'ro', isa => 'Int';
        B<< has 'diet', is => 'rw'; >>
    }

    my $fat = Cat->new( name => 'Fatty',
                        age  => 8,
                        diet => 'Sea Treats' );

    say $fat->name(), ' eats ', $fat->diet();

    B<< $fat->diet( 'Low Sodium Kitty Lo Mein' ); >>
    say $fat->name(), ' now eats ', $fat->diet();

=end programlisting

C<ro>-аксессор, используемый как мутатор, выбросит исключение C<Cannot assign a
value to a read-only accessor at ...>.

Использование C<ro> или C<rw> E<mdash> вопрос дизайна, удобства и чистоты. Moose
не принуждает к какой-то определённой философии в этой области. Некоторые
предлагают делать все данные экземпляра C<ro>, чтобы необходимо было передавать
данные экземпляра в конструктор (L<immutability>). В примере с C<Cat> C<age()>
всё ещё может быть аксессором, но конструктор может принять I<год> рождения кота
и вычислить возраст сам исходя из текущего года. Этот подход усиливает код
валидации и гарантирует, что все создаваемые объекты будут иметь валидные
данные.

Данные экземпляра начинают демонстрировать значение объектной ориентации. Объект
содержит связанные данные и может выполнять действия с этими данными. Класс
только описывает эти данные и действия.

=head2 Инкапсуляция

X<encapsulation>
X<OO; encapsulation>

Moose позволяет вам объявить, I<какими> атрибутами обладают экземпляры класса
(у кота есть имя), а также атрибуты этих атрибутов (вы не можете изменить имя
кота; вы можете его только читать). Moose сам решает, как I<хранить> эти
атрибуты. Вы можете изменить это, если захотите, но позволение Moose управлять
вашим хранилищем поддерживает I<инкапсуляцию>: скрытие внутренних деталей
объекта от внешних пользователей этого объекта.

Рассмотрим изменение того, как C<Cat> управляет своим возрастом. Вместо передачи
значения возраста в конструктор, передадим год рождения кота и вычислим возраст
при необходимости:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name',        is => 'ro', isa => 'Str';
        has 'diet',        is => 'rw';
        B<< has 'birth_year',  is => 'ro', isa => 'Int'; >>

        B<sub age>
        B<{>
            B<my $self = shift;>
            B<my $year = (localtime)[5] + 1900;>

            B<< return $year - $self->birth_year(); >>
        B<}>
    }

=end programlisting

Хотя синтаксис I<создания> объектов C<Cat> изменился, синтаксис I<использования>
объектов C<Cat> остался прежним. Снаружи C<Cat> C<age()> ведёт себя так же, как
и раньше. I<Как> это работает внутренне E<mdash> это забота класса C<Cat>.

=begin tip Совместимость и API

Сохраните поддержку старого синтаксиса I<создания> объектов C<Cat>,
модифицировав генерируемый конструктор C<Cat>, чтобы позволить передавать
параметр C<age>. На основе него вычислите C<birth_year>. См.
C<perldoc Moose::Manual::Attributes>.

=end tip

X<attributes; default values>

Вычисление возраста имеет другое преимущество. I<Значение атрибута по умолчанию>
будет вести себя правильно в случае, если кто-нибудь создат новый объект C<Cat>,
не передав год рождения:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw', isa => 'Str';

        B<< has 'birth_year', >>
            B<< is      => 'ro', >>
            B<< isa     => 'Int', >>
            B<< default => sub { (localtime)[5] + 1900 }; >>
    }

=end programlisting

Ключевое слово C<default> у атрибута принимает ссылку на функциюN<Вы можете
использовать простое значение, такое как число или строка, напрямую, но для
чего-либо более сложного используйте ссылку на функцию.>, которая возвращает
значение по умолчанию для этого атрибута при создании нового объекта. Если код,
создающий объект, не передас в конструктор значение для этого атрибута, объект
получит значение по умолчанию:

=begin programlisting

    my $kitten = Cat->new( name => 'Choco' );

=end programlisting

E<hellip>и этот котёнок будет иметь возраст C<0> до следующего года.

=head3 Полиморфизм

Инкапсуляция полезна, но настоящие возможности объектного-ориентированного
подхода намного шире. Хорошо спроектированная ОО-программа может управлять
множеством типов данных. Когда хорошо спроектированные классы инкапсулируют
конкретные детали объектов в соответствующих местах, происходит нечто
любопытное: код зачастую становится I<менее> конкретным.

Перемещение деталей того, что программа знает об отдельных объектах C<Cat>
(атрибуты), и того, что программа знает о том, что объекты C<Cat> могут делать
(методы) в класс C<Cat> означает, что код, работающий с экземплярами C<Cat>,
будет успешно игнорировать то, I<как> C<Cat> делает то, что он делает.

Рассмотрим функцию, выводяющую детали объекта:

=begin programlisting

    sub show_vital_stats
    {
        my $object = shift;

        say 'My name is ', $object->name();
        say 'I am ',       $object->age();
        say 'I eat ',      $object->diet();
    }

=end programlisting

X<genericity>
X<OO; genericity>

Очевидно (из контекста), что эта функцию работает, если вы передадите ей объект
C<Cat>. Фактически, она будет делать то, что нужно, для любого объекта, имеющего
три соответствующих аксессора, независимо от того, I<как> этот объект
предоставляет эти аксессоры, и независимо от того, I<что> это за объект: C<Cat>,
C<Caterpillar> или C<Catbird>. Функция имеет достаточно общий вид, чтобы любой
объект, обеспечивающий этот интерфейс, будет корректным параметром.

X<polymorphism>
X<OO; polymorphism>

Это свойство I<полиморфизма> означает, что вы можете заменить объект одного
класса объектом другого класса, если они предоставляют один и тот же внешний
интерфейс.

=begin tip Утиная типизация

X<duck typing>
X<OO; duck typing>

Некоторые языки и среды требуют установления формального отношения между двумя
классами прежде чем позволить программе заменять экземпляры одного экземплярами
другого. Perl 5 предоставляет способы сделать эти проверки обязательными, но не
требует их. Его стандартная ad-hoc-система позволяет вам обращаться с двумя
любыми экземплярами, имеющими одинаково названные методы, как с достаточно
эквивалентными. Некоторые называют это I<утиной типизацией>, утверждая, что
любой объект, который может крякать (C<quack()>) достаточно поход на утку, чтобы
с ним можно было обращаться как с уткой.

=end tip

C<show_vital_stats()> заботится о том, чтобы вызывающая сущность была валидна
только в смысле поддержки этих трёх методов, C<name()>, C<age()> и C<diet()>,
какждый из которых не имеет аргументов и возвращает нечто, что можно
конкатенировать в строковом контексте. Вы можете иметь в своём коде сотню разных
классов, ни один из которых не будет иметь каких-либо очевидных взаимосвязей, но
они будут работать с этим методом, если они соответствуют этому ожидаемому
поведению.

Подумайте, как вы могли бы пересчитать целый зоопарк животных без этой
полиморфной функции? Выгода универсальности должна быть очевидна. Также, любые
специфичные детали того, как рассчитать возраст оцелота или осьминога, могут
принадлежать соответствующему классу E<mdash> где они имеют наибольшее значение.

Конечно, одно лишь существование методов с именами C<name()> или C<age()> само
по себе не определяет поведение объекта. Для объекта C<Dog> C<age()> может быть
аксессором, с помощью которого вы можете узнать, что C<$rodney> E<mdash> 9 лет,
а C<$lucky> E<mdash> 4 года. Объект C<Cheese> может иметь метод C<age()>,
который позволяет вам контролировать, как долго хранить C<$cheddar> чтобы его
вкус заострился. C<age()> может быть аксессором в одном классе, но не в другом:

=begin programlisting

    # сколько лет коту?
    my $years = $zeppie->age();

    # хранить сыр на складе шесть месяцев
    $cheese->age();

=end programlisting

Иногда полезно знать, I<что> делает объект, и что это I<означает>.

=head2 Роли

Z<roles>
X<roles>

I<Роль> E<mdash> это именованная совокупность поведений и состоянийN<Смотрите
дизайн-документы Perl 6 на тему ролей по адресу
U<http://feather.perl6.nl/syn/S14.html> и исследуйте трейты Smalltalk на
странице U<http://scg.unibe.ch/research/traits> для получения обширных
подробностей.>. Тогда как класс организует поведения и состояние в шаблон для
создания объектов, роль организует именованную коллекцию поведений и состояния.
Вы можете создать экземпляр класса, но не роли. Роль E<mdash> это что-то, что
делает класс.

Если у нас есть C<Animal>, имеющий возраст, и C<Cheese>, имеющий возраст,
разница между ними может быть в том, что C<Animal> выполняет роль
C<LivingBeing>, тогда как C<Cheese> выполняет роль C<Storable>:

=begin programlisting

    package LivingBeing
    {
        use Moose::Role;

        requires qw( name age diet );
    }

=end programlisting

Всё, что имеет эту роль, должно предоставлять методы C<name()>, C<age()> и
C<diet()>. Класс C<Cat> может явно обозначить, что он имеет эту роль:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw', isa => 'Str';

        has 'birth_year',
            is      => 'ro',
            isa     => 'Int',
            default => sub { (localtime)[5] + 1900 };

        B<with 'LivingBeing';>

        sub age { ... }
    }

=end programlisting

X<roles; composition>

Строчка C<with> заставляет Moose I<скомпоновать> роль C<LivingBeing> в класс
C<Cat>. Компоновка гарантирует, что все атрибуты и методы роли являются частью
класса. C<LivingBeing> требует от любого компонуемого класса предоставлять
методы с названиями C<name()>, C<age()> и C<diet()>. C<Cat> удовлетворяет этим
ограничениям. Если C<LivingBeing> была скомпонована в класс, который не
предоставляет эти методы, Moose бы выбросил исключение.

=begin tip Порядок имеет значение!

Ключевое слово C<with>, используемое для применение роли к классу, должно
находиться I<после> объявлений атрибутов, чтобы компоновка могла распознать
все сгенерированные методы-аксессоры.

=end tip

Теперь все экземпляры C<Cat> будут возвращать истинное значение если их
запросить, предоставляют ли они роль C<LivingBeing>. А объекты C<Cheese> не
будут:

=begin programlisting

    say 'Alive!' if $fluffy->DOES('LivingBeing');
    say 'Moldy!' if $cheese->DOES('LivingBeing');

=end programlisting

Эта техника проектирования отделяет I<возможности> классов и объектов от
I<реализации> этих классов и объектов. Поведение вычисления года рождения класса
C<Cat> само по себе тоже может быть ролью:

=begin programlisting

    package CalculateAge::From::BirthYear
    {
        use Moose::Role;

        has 'birth_year',
            is      => 'ro',
            isa     => 'Int',
            default => sub { (localtime)[5] + 1900 };

        sub age
        {
            my $self = shift;
            my $year = (localtime)[5] + 1900;

            return $year - $self->birth_year();
        }
    }

=end programlisting

Выделение этой роли из C<Cat> делает полезное поведение доступным для других
классов. Теперь C<Cat> может компоновать обе роли:

=begin programlisting

    package Cat
    {
        use Moose;

        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw';

        B<with 'LivingBeing',>
             B<'CalculateAge::From::BirthYear';>
    }

=end programlisting

Обратите внимание как метод C<age()> из C<CalculateAge::From::BirthYear>
удовлетворяет требование роли C<LivingBeing>. Также заметьте, что любая провера
того, что C<Cat> выполняет роль C<LivingBeing>, возвращает истинное значение.
Выделение C<age()> в роль изменило только детали того, I<как> C<Cat> вычисляет
возраст. Это всё ещё C<LivingBeing>. C<Cat> может выбрать, имплементировать ли
свой собственный возраст или получить его откуда-то ещё. Всё что имеет значение
E<mdash> это то, что он предоставляет C<age()>, который удовлетворяет
ограничениям C<LivingBeing>.

X<allomorphism>
X<roles; allomorphism>

Как полиморфизм означает, что вы можете работать с разными объектами, имеющими
одно и то же поведение, одним и тем же способом, так и этот I<алломорфизм>
означает, что объект может реализовывать одно и то же поведение разными
способами.

Глубокий алломорфизм может уменьшить размер ваших классов и увеличить количество
кода, разделяемого между ними. Он также позволяет вам именовать специфичные и
обособленные поведения E<mdash> очень полезно для проверки возможностей вместо
реализаций.

X<OO; mixins>
X<OO; multiple inheritance>
X<OO; monkeypatching>

Для сравнения ролей с другими техниками проектирования, такими как примеси,
множественное наследование и манкипатчинг см.
U<http://www.modernperlbooks.com/mt/2009/04/the-why-of-perl-roles.html>.

=head3 Роли и DOES()

X<C<DOES()>>
X<Moose; C<DOES()>>

Если вы компонуете роль в класс, класс и его экземпляры будут возвращать
истинное значение если вы вызовете на них C<DOES()>:

=begin programlisting

    say 'This Cat is alive!'
        if $kitten->DOES( 'LivingBeing' );

=end programlisting

=head2 Наследование

Z<inheritance>

X<inheritance>
X<OO; inheritance>
X<Moose; inheritance>

Объектная система Perl 5 поддерживает I<наследование>, которое устанавливает
связи между двумя классами, так, что один адаптирует другой. Дочерний класс
ведёт себя так же, как его родитель E<mdash> он имеет то же самое количество и
типы атрибутов, и вы можете использовать те же самые методы. Он может иметь
дополнительные данные и поведение, но вы можете использовать экземпляр дочернего
класса там, где код ожидает родительский. В некотором смысле, подкласс
предоставляет роль, предполагаемую существованием его родительского класса.

=begin tip Роли против наследования

Должны ли вы использовать роли или наследование? Роли предоставляют безопасность
времени компоновки, лучшую проверку типов, лучшее разбиение кода и более тонкий
контроль над именами и поведениями, но наследование более привычно опытным
разработчикам на других языках. Используйте наследование в случае, если один
класс на самом деле I<расширяет> другой. Используйте роль, если класс требует
дополнительного поведения, и если вы можете дать этому поведению осмысленное
имя.

=end tip

Рассмотрите класс C<LightSource>, который предоставляет два публичных атрибута
(C<enabled> и C<candle_power>) и два метода (C<light> и C<extinguish>):

=begin programlisting

    package LightSource
    {
        use Moose;

        has 'candle_power', is      => 'ro',
                            isa     => 'Int',
                            default => 1;

        has 'enabled', is      => 'ro',
                       isa     => 'Bool',
                       default => 0,
                       writer  => '_set_enabled';

        sub light
        {
            my $self = shift;
            $self->_set_enabled(1);
        }

        sub extinguish
        {
            my $self = shift;
            $self->_set_enabled(0);
        }
    }

=end programlisting

(Заметьте, что опция C<writer> атрибута C<enabled> создаёт приватный аксессор,
используемый в классе для установки значения.)

=head3 Наследование и атрибуты

Подкласс C<LightSource> может определить супер-свечу, дающую в сто раз больше
света:

=begin programlisting

    package SuperCandle
    {
        use Moose;

        B<extends 'LightSource'>;

        has 'B<+>candle_power', default => 100;
    }

=end programlisting

X<Moose; C<extends>>

C<extends> принимает списо имён классов для использования их в качестве
родителей текущего класса. Если бы это была единственная строка в этом классе,
объект C<SuperCandle> вёл бы себя в точности так же, как объекты C<LightSource>.
Он имел бы оба атрибута, C<candle_power> и C<enabled>, так же как и методы
C<light()> и C<extinguish()>.

C<+> в начале имени атрибута (как у C<candle_power>) указывает, что текущий
класс делает с этим атрибутом что-то особенное. Здесь супер-свеча переопределяет
значение по умолчанию источника света, так что любой новый созданный объект
C<SuperCandle> будет иметь световое значение в 100 свечей.

Когда вы вызываете C<light()> или C<extinguish()> на объекте C<SuperCandle>,
Perl будет искать методы в классе C<SuperCandle>, а затем в его родителе. В
данном случае эти методы находятся в классе C<LightSource>.

X<Moose; attribute inheritance>

Наследование атрибутов работает аналогично (см. C<perldoc Class::MOP>).

=head3 Порядок диспетчеризации методов

X<methods; resolution>
X<method resolution order>
X<methods; dispatch order>
X<multiple inheritance>
X<objects; inheritance>
X<objects; multiple inheritance>
X<MRO>

I<Порядок диспетчеризации методов> (I<или порядок разрешения методов>, I<method
resolution order> или I<MRO>) очевиден для классов, имеющих одного родителя.
Искать в классе объекта, затем в его родителе, и так далее до тех пор пока
метод не будет найден или родители не закончатся. Классы, наследующие от
нескольких родителей (I<множественное наследование>) E<mdash> C<Hovercraft>
расширяет и C<Boat>, и C<Car> E<mdash> требуют более хитрой диспетчеризации.
Суждение о множественном наследовании сложно. По возможности избегайте
множественного наследования.

Perl 5 использует стратегию разрешения методов поиском в глубину. Он ищет класс
родителя, названного I<первым>, и всех родителей этого родителя рекурсивно,
прежде чем искать в классах следующих родителей. Прагма C<mro> (L<pragmas>)
предоставляет альтернативные стратегии, включая стратегию C3 MRO, которая ищет
в непосредственных родителях заданного класса прежде чем искать в их родителях.

See C<perldoc mro> for more details.

=head3 Наследование и методы

X<Moose; overriding methods>
X<Moose; C<override>>

Как и с атрибутами, подклассы могут переопределять методы. Представьте свет,
который вы не можете потушить:

=begin programlisting

    package Glowstick
    {
        use Moose;

        extends 'LightSource';

        sub extinguish {}
    }

=end programlisting

Вызов C<extinguish()> на светящейся палочке не будет делать ничего, несмотря на
то, что метод из C<LightSource> что-то делает. Диспетчеризация методов найдёт
метод подкласса. Вы, возможно, не имели намерения так делать. Если вы его
имеете, используйте функцию Moose C<override> чтобы ясно выразить своё
намерение.

Внутри переопределённого метода функция Moose C<super()> позволит вам вызвать
переопределённый метод:

=begin programlisting

    package LightSource::Cranky
    {
        use Carp 'carp';
        use Moose;

        extends 'LightSource';

        B<override> light => sub
        {
            my $self = shift;

            carp "Can't light a lit light source!"
                if $self->enabled;

            B<super()>;
        };

        B<override> extinguish => sub
        {
            my $self = shift;

            carp "Can't extinguish unlit light source!"
                unless $self->enabled;

            B<super()>;
        };
    }

=end programlisting

Этот подкласс добавляет предупреждение при попытке зажечь или потушить источник
света, который уже находится в нужном состоянии. Функция C<super()> отправляет
к реализации текущего метода в ближайшем родителе, согласно стандартному порядку
разрешения методов Perl 5.

=begin tip Работает на Moose

Модификаторы методов Moose могут делать похожие вещи E<mdash> и больше. Смотрите
C<perldoc Moose::Manual::MethodModifiers>.

=end tip

=head3 Наследование и isa()

X<C<isa()>>
X<Moose; C<isa()>>

Метод C<isa()> в Perl возвращает истину, если его вызывающая сущность является
или расширяет названный класс. Эта вызывающая сущность может быть именем класса
или экземпляром объекта.

=begin programlisting

    say 'Looks like a LightSource'
        if $sconce->isa( 'LightSource' );

    say 'Hominidae do not glow'
        unless $chimpy->isa( 'LightSource' );

=end programlisting

=head2 Moose и Perl 5 ООП

X<Moose; compared to default Perl 5 OO>

Moose предоставляет много возможностей помимо стандартного ООП Perl 5. Хотя вы
I<можете> построить всё, что вы получаете с Moose, сами (L<blessed_references>),
или смастерить это из нескольких CPAN-дистрибутивов, Moose заслуживает
использования. Это логически связанное целое, с хорошей документацией. Многие
важные проекты успешно его используют. Он имеет зрелое и внимательное сообщество
разработчиков.

X<metaprogramming>
X<Moose; MOP>
X<Moose; metaprogramming>
X<C<Class::MOP>>
X<C<Class::MOP::Class>>

Moose позаботится о конструкторах, деструкторах, аксессорах и инкапсуляции. Вам
придётся объявить, чего вы хотите, но то, что вы получите, будет безопасным и
простым в использовании. Объекты Moose могут расширять и работать с объектами
ванильной системы Perl 5.

Moose также даёт возможность I<метапрограммирования> E<mdash> манипулирования
вашими объектами через сам Moose. Если вы когда-нибудь интересовались, какие
методы доступны в классе или объекте, или какие атрибуты объект поддерживает,
эта информация доступна:

=begin programlisting

    my $metaclass = Monkey::Pants->meta();

    say 'Monkey::Pants instances have the attributes:';

    say $_->name for $metaclass->get_all_attributes;

    say 'Monkey::Pants instances support the methods:';

    say $_->fully_qualified_name
        for $metaclass->get_all_methods;

=end programlisting

Вы даже можете увидеть, какие классы расширяют заданный класс:

=begin programlisting

    my $metaclass = Monkey->meta();

    say 'Monkey is the superclass of:';

    say $_ for $metaclass->subclasses;

=end programlisting

Смотрите C<perldoc Class::MOP::Class> для большей информации об операциях
метаклассов и C<perldoc Class::MOP> для информации о метапрограммировании Moose.

Moose и его I<протокол метаобъектов> (I<meta-object protocol>, или MOP) даёт
возможность лучшего синтаксиса для объявления и работы с классами и объектами в
Perl 5. Это корректный код на Perl 5:

=begin programlisting

    use MooseX::Declare;

    B<role> LivingBeing { requires qw( name age diet ) }

    B<role> CalculateAge::From::BirthYear
    {
        has 'birth_year',
            is      => 'ro',
            isa     => 'Int',
            default => sub { (localtime)[5] + 1900 };

        B<method> age
        {
            return (localtime)[5] + 1900
                                  - $self->birth_year();
        }
    }

    B<class Cat with LivingBeing>
              B<with CalculateAge::From::BirthYear>
    {
        has 'name', is => 'ro', isa => 'Str';
        has 'diet', is => 'rw';
    }

=end programlisting

X<CPAN; C<MooseX::Declare>>
X<CPAN; C<Devel::Declare>>

CPAN-дистрибутив C<MooseX::Declare> использует C<Devel::Declare> для добавления
нового Moose-специфичного синтаксиса. Ключевые слова I<class>, I<role> и
I<method> уменьшают количество текста, необходимого для написания хорошего
объектно-ориентированного кода на Perl 5. Обратите особое внимание на
декларативную природу этого примера, а также на отсутствие C<my $self = shift;>
в C<age()>.

Хотя Moose и не является частью ядра Perl 5, его популярность гарантирует его
доступность в дистрибутивах многих ОС. Дистрибутивы Perl 5, такие как Strawberry
Perl и ActivePerl, тоже его включают. Несмотря на то, что Moose E<mdash>
CPAN-модуль, его чистота и простота делают его неотъемлемой частью современного
Perl-программирования.

=begin tip Стройный I<лось>

X<CPAN; C<Any::Moose>>

Moose не маленькая, но мощная библиотека. CPAN-модуль C<Any::Moose> помогает
уменьшить стоимость возможностей, которые вы не используете.

=end tip
