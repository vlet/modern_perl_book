=head1 Модули

Z<modules>

X<modules>

Многие считают CPAN (L<cpan>) самой мощной возможностью Perl 5. CPAN, по сути,
представляет собой систему для поиска и установки модулей. I<Модуль> E<mdash> это
пакет, содержащийся в своём собственном файле, который можно загружать с помощью
C<use> или C<require>. Модуль должен быть валидным кодом на Perl 5. Он должен
завершаться выражением, возвращающим истинное значение, чтобы парсер Perl 5 мог
понять, что он успешно загрузил и скомпилировал модуль. Других требований нет,
только твёрдые соглашения.

X<C<::>; package name separator>

Когда вы загружаете модуль, Perl разбивает имя пакета по двойным двоеточиям
(C<::>) и превращает компоненты имени пакета в имя файла. На практике,
C<use StrangeMonkey;> заставляет Perl искать файл с именем F<StrangeMonkey.pm>
во всех директориях, входящих в C<@INC>, по порядку, пока он его не найдёт или
не израсходует список.

Аналогично, C<use StrangeMonkey::Persistence;> заставляет Perl искать файл с
именем F<Persistence.pm> в каждой директории с именем F<StrangeMonkey/>,
находящейся в любой из директорий, входящих в C<@INC>, и т. д.
C<use StrangeMonkey::UI::Mobile;> заставляет Perl искать относительный файловый
путь F<StrangeMonkey/UI/Mobile.pm> в каждой директории в C<@INC>.

Результирующий файл может содержать или не содержать объявление пакета,
совпадающее с именем файла E<mdash> такого технического I<требования> нет
E<mdash> но вопросы поддержки рекомендуют это соглашение.

=begin tip Трюки C<perldoc>

X<C<perldoc>; C<-l>>
X<C<perldoc>; C<-m>>
X<C<perldoc>; C<-lm>>

C<perldoc -l Module::Name> выведет полный путь к соответствующему файлу F<.pm>,
в случае, если I<документация> к этому модулю существует в файле F<.pm>.
C<perldoc -lm Module::Name> выведет полный путь к файлу F<.pm>, независимо от
существования параллельного файла F<.pod>. C<perldoc -m Module::Name> отобразит
содержимое файла F<.pm>.

=end tip

=head2 Использование и импортирование

Z<import>

X<builtins; C<use>>
X<C<import()>>
X<C<CGI>>
X<C<feature> pragma>
X<pragmas; C<feature>>

Когда вы загружаете модуль с помощью C<use>, Perl загружает его с диска, а затем
вызывает его метод C<import()>, передавая все указанные вами аргументы. По
соглашению метод C<import()> модуля принимает список имён и экспортирует функции
и другие символы в вызывающее пространство имён. Это всего лишь соглашение;
модуль может отказаться предоставлять C<import()>, или его C<import()> может
выполнять другие действия. Прагмы (L<pragmas>), такие как C<strict>, используют
аргументы для изменения поведения вызывающей лексической области видимости
вместо экспорта символов:

=begin programlisting

    use strict;
    # E<hellip>вызывает strict->import()

    use CGI ':standard';
    # E<hellip>вызывает CGI->import( ':standard' )

    use feature qw( say switch );
    # E<hellip>вызывает feature->import( qw( say switch ) )

=end programlisting

X<builtins; C<no>>
X<unimporting>

Встроенная директива C<no> вызывает метод C<unimport()> модуля, если он
существует, передавая любые аргументы. Это наиболее распространено с прагмами,
использование которых модифицирует поведение через C<import()>:

=begin programlisting

    use strict;
    # запрещены символьные ссылки или голые слова
    # требуется объявление переменных

    {
        no strict 'refs';
        # символьные ссылки разрешены
        # ограничения 'subs' и 'vars' всё ещё активны
    }

=end programlisting

И C<use>, и C<no> действуют во время компиляции, так что:

=begin programlisting

    use Module::Name qw( list of arguments );

=end programlisting

E<hellip>это то же самое, что:

=begin programlisting

    BEGIN
    {
        require 'Module/Name.pm';
        Module::Name->import( qw( list of arguments ) );
    }

=end programlisting

Аналогично:

=begin programlisting

    no Module::Name qw( list of arguments );

=end programlisting

E<hellip>это то же самое, что:

=begin programlisting

    BEGIN
    {
        require 'Module/Name.pm';
        Module::Name->unimport(qw( list of arguments ));
    }

=end programlisting

E<hellip>включая C<require> модуля.

=begin tip По отсутствующим методам никто не скучает

Если C<import()> или C<unimport()> не существует в модуле, Perl не будет
выдавать сообщение об ошибке. Они совершенно опциональны.

=end tip

Вы I<можете> вызвать C<import()> и C<unimport()> напрямую, хотя за пределами
блока C<BEGIN> делать это мало смысла; после завершения компиляции действие
C<import()> или C<unimport()> может не иметь особого эффекта.

X<modules; case-sensitivity>
X<case-sensitivity>

В Perl 5 C<use> и C<require> регистрозависимы, хотя, в то время как Perl
понимает разницу между C<strict> и C<Strict>, ваше сочетание операционной
системы и файловой системы может не знать. Если бы вы написали C<use Strict;>,
Perl не нашёл бы F<strict.pm> в регистрозависимых файловых системах. В
регистронезависимых файловых системах Perl охотно загрузит F<Strict.pm>, но
когда он попытается вызвать  C<< Strict->import() >>, ничего не случится.
(F<strict.pm> объявляет пакет с именем C<strict>.)

Переносимые программы придерживаются строгих правил относительно этого случая,
даже если и не обязаны.

=head2 Экспортирование

Z<exporting>
X<exporting>

Модуль может сделать определённые глобальные символы доступными другим пакетам
посредством процесса, известного как I<экспорт> E<mdash> процесс, инициируемый
вызовом C<import()>, явным или неявным.

X<C<Exporter>>
X<C<Exporter>; C<@EXPORT_OK>>
X<C<Exporter>; C<@EXPORT>>

Базовый модуль C<Exporter> предоставляет стандартный механизм экспорта
символов из модуля. C<Exporter> полагается на присутствие глобальных переменных
пакета E<mdash> в частности, C<@EXPORT_OK> и C<@EXPORT> E<mdash> которые
содержат список символов, экспортируемых по запросу.

Рассмотрим модуль C<StrangeMonkey::Utilities>, предоставляющий несколько
автономных функций, применимых по всей системе:

=begin programlisting

    package StrangeMonkey::Utilities;

    use Exporter 'import';

    our @EXPORT_OK = qw( round translate screech );

    ...

=end programlisting

Любой другой код теперь может использовать этот модуль и, опционально,
импортировать любую или все три экспортируемые функции. Также вы можете
экспортировать переменные:

=begin programlisting

    push @EXPORT_OK, qw( $spider $saki $squirrel );

=end programlisting

Экспортируйте символы по умолчанию, перечислив их в C<@EXPORT> вместо
C<@EXPORT_OK>:

=begin programlisting

    our @EXPORT = qw( monkey_dance monkey_sleep );

=end programlisting

E<hellip>так что любая конструкция C<use StrangeMonkey::Utilities;> будет
импортировать обе функции. Имейте ввиду, что указание символов для импорта
I<не> импортирует символы по умолчанию, вы получите только то, что запросили.
Чтобы загрузить модуль, не импортируя никаких символов, явно укажите пустой
список:

=begin programlisting

    # сделать модуль доступным, но ничего не импортировать
    use StrangeMonkey::Utilities ();

=end programlisting

Независимо от любых списков импорта, вы всегда можете вызвать функции из другого
пакета с помощью их полностью определённых имён:

=begin programlisting

    StrangeMonkey::Utilities::screech();

=end programlisting

=begin tip Упрощённое экспортирование

X<CPAN; C<Sub::Exporter>>

CPAN-модуль C<Sub::Exporter> предоставляет более приятный интерфейс для экспорта
функций без использования глобальных переменных пакета. Он также предлагает
более широкие настройки. Однако, C<Exporter> может экспортировать переменные,
тогда как C<Sub::Exporter> экспортирует только функции.

=end tip

=head2 Организация кода с помощью модулей

Perl 5 не заставляет вас использовать ни модули, ни пакеты, ни пространства
имён. Вы можете разместить весь свой код в единственном файле F<.pl>, или в
нескольких файлах F<.pl>, подключаемых с помощью C<require> по необходимости.
Вам предоставлена гибкость в управлении вашим кодом наиболее соответствующим
способом, в зависимости от вашего стиля разработки, формальностей, рисков и
вознаграждений проекта, вашего опыта и вашего комфорта в развёртывании Perl 5.

Несмотря на это, проект с более чем несколькими сотнями строк кода получает
множество преимуществ от модульной организации:

=over 4

=item * Модули помогают обеспечить логическое разделение между отдельными
сущностями в системе.

=item * Модули предоставляют границы API, процедурного или ОО.

=item * Модули предлагают естественную организацию исходного кода.

=item * Экосистема Perl 5 имеет множество инструментов, предназначенных для
создания, поддержки, организации и развёртывания модулей и дистрибутивов.

=item * Модули предоставляют механизм повторного использования кода.

=back

Даже если вы не используете объектно-ориентированный подход, моделирование
каждой отдельной сущности или ответственности в вашей системе в виде её
собственного модуля сохраняет связанный код вместе и независимый код раздельно.
