=head1 Голые слова

Z<barewords>

Perl E<mdash> податливый язык. Вы можете писать программы в наиболее творческой,
поддерживаемой, запутанной или эксцентричной предпочитаемой вами манере.
Поддерживаемость E<mdash> забота хороших программистов, но Perl не допускает
диктовать, что I<вы> считаете поддерживаемым.

X<barewords>
X<C<strict> pragma>
X<pragmas; C<strict>>

Парсер Perl понимает встроенные функции и операторы Perl. Он использует сигилы
для идентификации переменных и другую пунктуацию для распознавания вызовов
функций и методов. Однако иногда парсеру приходится догадываться, что вы имеете
ввиду, особенно когда вы используете I<голое слово> E<mdash> идентификатор без
сигила или другой синтаксически значимой пунктуации.

=head2 Хорошее использование голых слов

X<barewords; pros>

Хотя прагма C<strict> (L<pragmas>) справедливо запрещает неоднозначные голые
слова, некоторые голые слова могут быть приемлемы.

=head3 Голые слова как ключи хеша

X<hashes; bareword keys>
X<C<+>; unary operator>

Ключи хеша в Perl 5 обычно I<не> допускают неоднозначности, потому что парсер
может идентифицировать их как строковые ключи; C<pinball> в C<$games{pinball}>
E<mdash> это очевидно строка.

Иногда эта интерпретация E<mdash> не то, чего вы хотите, особенно если вы
намеревались I<вычислить> встроенную функцию или функцию чтобы сгенерировать
ключ хеша. В этом случае, устраните неоднозначность, указав аргументы, используя
круглые скобки для аргументов функции, или предварите унарным плюсом, чтобы
форсировать вычисление встроенной функции:

=begin programlisting

    # литеральный E<laquo>shiftE<raquo>, это ключ
    my $value = $items{B<shift>};

    # значение, возвращённое E<laquo>shiftE<raquo>, это ключ
    my $value = $items{B<shift @_>}

    # унарный плюс использует встроенную функцию E<laquo>shiftE<raquo>
    my $value = $items{B<+>shift};

=end programlisting

=head3 Голые слова как имена пакетов

X<packages; bareword names>

Имена пакетов в Perl 5 тоже являютя голыми словами. Если вы следуете соглашениям
о наименовании, согласно которым имена пакетов начинаются с заглавных букв, а
функции E<mdash> нет, маловероятно, что вы встретитесь с коллизиями имён, но
парсер Perl 5 должен определить, как парсить C<< Package->method() >>. Значит
ли это E<laquo>вызвать функцию с именем C<Package()> и вызвать метод C<method()>
на возвращаемом ей значенииE<raquo> или E<laquo>вызвать метод с именем
C<method()> в пространстве имён C<Package>E<raquo>? Ответ различается в
зависимости от того, какой код парсер уже встретил в текущем пространстве имён.

Принудите парсе воспринимать C<Package> как имя пакета, добавив разделитель
пакетов (C<::>)N<Даже среди тех, кто понимает, почему это работает, очень
немногие это делают.>:

=begin programlisting

    # вероятно метод класса
    Package->method();

    # определённо метод класса
    Package::->method();

=end programlisting

=head3 Голые слова как имена блоков кода

X<C<BEGIN>>
X<C<DESTROY>>
X<C<AUTOLOAD>>
X<C<INIT>>
X<C<UNITCHECK>>
X<C<CHECK>>
X<C<END>>

Специальные именованные блоки кода C<AUTOLOAD>, C<BEGIN>, C<CHECK>, C<DESTROY>,
C<END>, C<INIT> и C<UNITCHECK> E<mdash> это голые слова, которые I<объявляют>
функции без использования встроенной директивы C<sub>. Вы уже видели это раньше
(L<code_generation>):

=begin programlisting

    package Monkey::Butler;

    BEGIN { initialize_simians( __PACKAGE__ ) }

    sub AUTOLOAD { ... }

=end programlisting

Хотя вы I<можете> опустить C<sub> из объявления C<AUTOLOAD()>, немногие так
делают.

=head3 Голые слова как константы

X<constants; barewords>

Константы, объявленные с помощью прагмы C<constant>, можно использовать как
голые слова:

=begin programlisting

    # не используйте это для реальной аутентификации
    use constant NAME     => 'Bucky';
    use constant PASSWORD => '|38fish!head74|';

    return unless $name eq NAME && $pass eq PASSWORD;

=end programlisting

Обратите внимание, что эти константы I<не> интерполируются в строках,
заключённых в двойные кавычки.

X<prototypes; barewords>

Константы E<mdash> специальный случай прототипированных функций (L<prototypes>).
Когда вы предварительно объявляете функцию с прототипом, парсер знает, как
воспринимать эту функцию и будет предупреждать об ошибках неоднозначности
парсинга. Все остальные недостатки прототипов всё ещё применимы.

=head2 Неблагоразумное использование голых слов

X<barewords; cons>

Независимо от того, насколько внимательно вы пишете код, голые слова всё равно
приводят к неоднозначностям. Вы можете избежать большинства их использований,
но вам встретится несколько типов голых слов в унаследованном коде.

=head3 Голые вызовы функций

X<barewords; function calls>
X<C<B::Deparse>>

Код, написанный без C<strict 'subs'>, может использовать голые имена функций.
Добавление скобок заставляет код пройти эти ограничения. Используйте
C<perl -MO=Deparse,-p> (см. C<perldoc B::Deparse>) чтобы понять, как Perl парсит
их, затем расставляйте скобки соответствующим образом.

=head3 Голые значения хешей

X<barewords; hash values>

Некоторый старый код может не заботиться о том, чтобы заключить в кавычки
I<значения> хеш-пар:

=begin programlisting

    # плохой стиль; не использовать
    my %parents =
    (
        mother => Annette,
        father => Floyd,
    );

=end programlisting

Если не существует ни функции C<Floyd()>, ни C<Annette()>, Perl будет
интерпретировать эти голые слова как строки. C<strict 'subs'> выдаст ошибку в
этой ситуации.

=head3 Голые дескрипторы файлов

X<barewords; filehandles>

До появления лексических дескрипторов файлов (L<lexical_filehandles>) все
дескрипторы файлов и директорий использовали голые слов. Вы почти всегда можете
безопасно переписать этот код на использование лексических дескрипторов файлов;
исключения E<mdash> C<STDIN>, C<STDOUT> и C<STDERR>. К счастью, парсер Perl
распознаёт их.

=head3 Голые функции sort

X<barewords; sort functions>
X<C<sort>>
X<builtins; C<sort>>

Наконец, встроенная фукнция C<sort> может принимать в качестве второго аргумента
I<имя> функции, которую нужно использовать для сортировки. Хотя это редко бывает
неоднозначным для парсера, это может смутить читающих I<людей>. Альтернатива в
виде передачи ссылки на функцию в скаляре немного лучше:

=begin programlisting

    # стиль с использованием голого слова
    my @sorted = sort compare_lengths @unsorted;

    # ссылка на фукнцию в скаляре
    my $comparison = \&compare_lengths;
    my @sorted     = sort $comparison @unsorted;

=end programlisting

Второй вариант избегает использования голого слова, но результат на одну строчку
длиннее. К сожалению, парсер Perl 5 I<не> понимает однострочную версию
вследствие специального парсинга C<sort>; вы не можете использовать произвольное
выражение (такое как взятие ссылки на именованную функцию) там, где может пройти
блок или скаляр.

=begin programlisting

    # не работает
    my @sorted = sort \&compare_lengths @unsorted;

=end programlisting

В обоих случаях то, как C<sort> вызывает функцию и передаёт аргументы, может
быть запутывающим (см. C<perldoc -f sort> для подробностей). Где возможно,
рассмотрите использование вместо этого блочной формы C<sort>. Если же вы должны
использовать какую-либо из форм с фукнцией, рассмотрите добавление объясняющего
комментария.
