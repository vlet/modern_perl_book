=encoding utf8

=head1 Значения

Z<values>

X<переменные>
X<значения>

Структура программы сильно зависит от способов, которыми вы формируете ваши
данные в соответствующих переменных.

Если переменные позволяют абстрактные манипуляции с данными - значениями,
которые они содержат, то это делает программу конкретной и полезной. Чем более
точны ваши значения, тем лучше ваши программы. Эти значения: имя и адрес вашей
тёти, дистанция между вашим офисом и обширным пространством до луны, или вес
всех печенек, которые вы съели за прошлый год. В вашей программе правила
относительно формата этих данных часто бывают строгими. Эффективные программы
требуют эффективных (простых, быстрых, наиболее компактных, наиболее
действенных) способов представления их данных.

=head2 Строки

X<Строки>

I<Строка> - это экземпляр текстовых или двоичных данных без особенного
форматирования или содержимого. Это может быть ваше имя, содержимое файла
изображения или сама ваша программа. Строка имеет смысл в программе, только если
вы наделяете её смыслом.

X<строки; разделители>

Для представления литеральной строки в вашей программе, окружите её парой
символов кавычек. Наиболее распространённые I<ограничители строк> - это
одиночные и двойные кавычки:

=begin programlisting

    my $name    = B<'Donner Odinson, Bringer of Despair'>;
    my $address = B<"Room 539, Bilskirnir, Valhalla">;

=end programlisting

X<строки; одиночные кавычки>

Символы I<строки в одиночных кавычках> представляют себя литерально, с двумя
исключениями. Вставка одиночных кавычек внутрь строки в одиночных кавычках
требует экранирования кавычки при помощи предваряющей обратной косой черты:

=begin programlisting

    my $reminder = 'Не забудB<\'>те экранировать '
                 . 'одиночную кавычку!';

=end programlisting

Вы также должны экранировать любую обратную косую черту в конце строки, чтобы
избежать экранирования завершающего ограничителя строки, что вызовет
синтаксическую ошибку:

=begin programlisting

    my $exception = 'Это строка завершается '
                  . 'обратной косой чертой, а не кавычкой: B<\\>';

=end programlisting

Любая другая обратная косая черта будет частью строки как она есть, за
исключением двух смежных обратных косых черт, в этом случае первая экранирует
вторую:

=begin programlisting

    is('Современный B<\> Perl', 'Современный B<\\> Perl',
        'экранирование обратной косой черты в одиночных кавычках');

=end programlisting

X<строки; двойные кавычки>

Для I<Строки в двойных кавычках> доступно больше специальных символов. Например,
вы можете закодировать невидимые пробельные символы в строку:

=begin programlisting

    my $tab       = "B<\t>";
    my $newline   = "B<\n>";
    my $carriage  = "B<\r>";
    my $formfeed  = "B<\f>";
    my $backspace = "B<\b>";

=end programlisting

Это демонстрирует полезный принцип: синтаксис для определения строки может
варьироваться. Вы можете указать табуляцию внутри строки с помощью
последовательности C<\t> или непосредственным набором табуляции. С точки зрения
Perl, обе строки ведут себя одинаково, даже если данное представление строки
может отличаться в исходном коде.

Определение строки может разбиваться на несколько строчек кода; эти два
определения эквивалентны:

=begin programlisting

    my $escaped = "две\nстрочки";
    my $literal = "две
    строчки";
    is $escaped, $literal, 'равнозначность \n и перевода строки';

=end programlisting

Эти последовательности часто бывает проще воспринимать, чем их пробельные
эквиваленты.

X<конкатенация>
X<строки; конкатенация>
X<операторы; C<.>>

Строки в Perl имеют переменную длину. По мере того, как вы манипулируете и
изменяете строки, Perl соответственно меняет их размер. Например, вы можете
объединить несколько строк в одну большую с помощью оператора I<конкатенации>
C<.>:

=begin programlisting

    my $kitten = 'Choco' . ' ' . 'Spidermonkey';

=end programlisting

Это в действительности тоже самое, как если бы вы инициализировали строку сразу
целиком.

X<интерполяция>
X<строки; интерполяция>

Вы также можете I<вставлять> значения скалярных переменных или значений массива
внутри строк с двойными кавычками, так I<текущее> содержимое переменной
становится частью строки, как если бы вы объединили их:

=begin programlisting

    my $factoid = "B<$name> живёт на B<$address>!";

    # эквивалентно
    my $factoid = $name . ' живет на ' . $address . '!';

=end programlisting

X<экранирование>

Включение литеральной двойной кавычки внутри строки с двойными кавычками,
требует её экранирования (то есть, вставки перед ней обратной косой черты):

=begin programlisting

    my $quote = "\"Ой,\", он заплакал.  \"Это было I<больно>!\"";

=end programlisting

X<операторы; цитирование>
X<C<q>; оператор одиночной кавычки>
X<операторы; C<q>>
X<C<qq>; оператор двойной кавычки>
X<операторы; C<qq>>

Когда повторяющееся обратные косые черты становятся громоздкими, используйте
альтернативный I<оператор цитирования>, которым вы можете задать альтернативный
ограничитель строки. Оператор C<q> соответствует одиночной кавычке, а оператор
C<qq> имеет поведение двойной кавычки. Символ, который следует за оператором,
становится символом ограничителя строки. Если символ является открывающим
символом парной группы -- такой как открывающая и закрывающая скобки --, то
закрывающий символ будет конечным ограничителем. В противном случае, символ сам
по себе будет начальным и конечным ограничителем.

=begin programlisting

    my $quote     = B<qq{>"Ой", сказал он.  "Это было I<больно>!"B<}>;
    my $reminder  =  B<q^>Не надо 'экранировать' одиночные кавычки!B<^>;
    my $complaint =  B<q{>It's too early to be awake.B<}>;

=end programlisting

X<встроенный документ>
X<строки; встроенный документ>

Когда определение сложной строки с набором встроенных экранирующих
последовательностей становится утомительным, используйте синтаксис I<встроенного
документа>, чтобы присвоить одну или несколько строчек строки:

=begin programlisting

    my $blurb =<<'END_BLURB';

    Он посмотрел вверх. "Время не на нашей строне, моё дитя.
    Видишь ли ты иронию? Всё, что они знают - это изменение.
    Изменение - это единственное, на что они могут согласиться.
    Вместо этого мы, рождённые вне времени, остаёмся совершенными
    и совершенно самодостаточными. Мы испытываем изменение, только
    если преследуем его. Это против нашей природы. Мы восстаём
    против этого изменения. Должны ли мы считать их
    способными на это?"
    END_BLURB

=end programlisting

Синтаксис C<< <<'END_BLURB' >> состоит из трёх частей. Двойные угловые скобки
открывают встроенный документ. Кавычки определяют какое поведение будет
выполнять встроенный документ: одиночных или двойных кавычек. Поведение по
умолчанию - это поведение двойных кавычек. C<END_BLURB> - это произвольный
идентификатор, который парсер Perl 5 будет воспринимать как завершающий
ограничитель.

Будьте внимательны, независимо от отступов самого встроенного документа,
завершающий ограничитель I<должен> начинаться вначале строки:

=begin programlisting

    sub some_function {
        my $ingredients =<<'END_INGREDIENTS';
        Два яйца
        Одна чашка муки
        Две униции масла
        Четверть чайно ложки соли
        Одна чашка молока
        Одна капля ванили
        Приправы по вкусу
    END_INGREDIENTS
    }

=end programlisting

=begin sidebar

Если идентификатор начинается с пробела, тот же пробел должен присутствовать
перед завершающим ограничителем. И даже если вы сделаете отступ перед
идентификатором, Perl 5 I<не> удалит подобные отступы в начале строчек
встроенного документа.

=end sidebar

Использование строки в нестроковом контексте приведёт к принудительному
преобразованию (L<coercion>).

=head2 Юникод и Строки

Z<unicode>
X<Юникод>

I<Юникод> - это система представления символов письменных языков мира. Хотя
большая часть Английских текстов использует набор из только 127 символов (что
требует семи бит для хранения и удачно влезает в восьмибитный байт), тем не
менее наивно верить, что вам когда-нибудь не потребуется поставить в слове
ударE<eacute>ние.

Строки в Perl 5 могут представлять один из двух различных, но связанных типов
данных:

X<код символа>

=over 4

=item Последовательность символов Юникод

Каждый символ имеет код, уникальное число, которое идентифицирует его в таблице
символов Юникод.

=item Последовательность октетов

X<октет>

Двоичные данные - это последовательность I<октетов> -- 8-битных чисел, каждое из
которых представляет число в диапазоне о 0 до 255.

=back

=begin tip Слова имеют значение

Почему I<октет>, а не I<байт>? Предположение, что один символ помещается в один
байт приведёт вас в вечный ад Юникода. Различайте идеи хранения в памяти и
представления символа.

=end tip

Юникодные строки и бинарные строки выглядят одинаково. Каждая имеет длину
C<length()>. Каждая поддерживает стандартные строковые операции, такие как
объединение, извлечение и обработка регулярными выражениями. Любая строка,
которая не является бинарными данными, должна быть последовательностью символов
Юникода.

Однако, из-за того, как ваша операционная система представляет данные с диска
или от пользователей или по сети -- как последовательность октетов -- Perl не
может знать являются ли данные, которые вы читаете файлом изображения, или
текстовым документом, или чем-то ещё. По умолчанию Perl воспринимает все
входящие данные как последовательность октетов. Вы должны сами наделять
специфическим значением эти данные.

=head3 Кодировка Символов

X<кодировка>
X<Юникод; кодировка>
X<UTF-8>
X<ASCII>
X<Latin-1>

Юникодная строка - это последовательность октетов, которые представляют
последовательность символов. I<Кодировка Юникода> устанавливает соответствие
между последовательностью октетов и символом. Такие кодировки, как UTF-8, могут
закодировать любой символ из набора Юникода. Другие кодировки представляют лишь
часть набора символом Юникода. Например, ASCII кодирует просто английский текст
без акцентированных символов, а Latin-1 может представлять текст для большей
части языков, которые используют латинский алфавит.

Для избежания большинства проблем с Юникодом, всегда декодируйте в/из
соответствующей кодировки на вводе и выводе вашей программы.

=begin tip Эволюция Стандарта

Perl 5.12 поддерживает стандарт Юникод 5.2, в то время как Perl 5.14
поддерживает Юникод 6.0. Если вам требуется знать о различиях между версиями
Юникода, вы возможно уже знаете, что нужно смотреть
U<http://unicode.org/versions/>.

=end tip

=head3 Юникод в Ваших Файловых Дескрипторах

X<C<open>>
X<встроенные; C<open>>
X<слои ввода/вывода>

Когда вы сообщаете Perl, что специфический файловый дескриптор (L<files>)
работает с кодированным текстом, Perl будет конвертировать входящие октеты в
юникодные строки автоматически. Для этого требуется добавить слой ввода/вывода к
режиму открытия файла во встроенной функции C<open>. I<Слой ввода/вывода>
становится обёрткой ввода или вывода и конвертирует данные. В данном случае,
слой C<:utf8> декодирует UTF-8 данные:

=begin programlisting

    use autodie;

    open my $fh, '<:utf8', $textfile;

    my $unicode_string = <$fh>;

=end programlisting

X<C<binmode>>
X<встроенные; C<binmode>>

Вы также можете изменить существующий файловый дескриптор с помощью C<binmode>,
неважно, для ввода или вывода:

=begin programlisting

    binmode $fh, ':utf8';
    my $unicode_string = <$fh>;

    binmode STDOUT, ':utf8';
    say $unicode_string;

=end programlisting

Без режима C<utf8>, печать строк Юникода в файловый дескриптор приведёт к
предупреждению (C<Wide character in %s>) (расширенный символ в %s), поскольку
файлы содержат октеты, а не символы Юникода.

=head3 Юникод в Ваших Данных

X<C<Encode>>
X<C<decode()>>
X<C<encode()>>

Базовый модуль C<Encode> предоставляет функцию, называемую C<decode()>, чтобы
конвертировать скаляр, содержащий данные, в строку Юникод. Соответствующая
функция C<encode()>, конвертирует из внутренней кодировки Perl в нужную вам
кодировку:

=begin programlisting

    my $from_utf8 = decode('utf8', $data);
    my $to_latin1 = encode('iso-8859-1', $string);

=end programlisting

=head3 Юникод в Ваших Программах

X<прагмы; C<utf8>>
X<C<utf8> прагма>
X<кодировка>

Вы можете использовать символы Юникода в ваших программах тремя способами.
Простейший способ это использовать прагму C<utf8> (L<pragmas>), которая сообщает
парсеру Perl интерпретировать дальнейший исходный код файла в кодировке UTF-8.
Это позволяет использовать символы Юникода в строках и идентификаторах:

=begin programlisting

    use utf8;

    sub E<pound>_to_E<yen> { ... }

    my $yen = E<pound>_to_E<yen>('1000E<pound>');

=end programlisting

Чтобы I<писать> такой код, ваш редактор должен понимать UTF-8 и вы должны
сохранить файл в соответствующей кодировке.

X<строки; C<\x{}>>
X<C<\x{}>; экранирующие последовательности для кодирования символов>

Внутри строк в двойных кавычках вы можете использовать экранирующие
последовательности Юникода, для представления кодированных символов. Синтаксис
C<\x{}> представляет единичный символ; вставьте шестнадцатеричную форму номера
символа Юникода внутри фигурных скобок:

=begin programlisting

    my $escaped_thorn = "\x{00FE}";

=end programlisting

X<прагма C<charnames>>
X<прагмы; C<charnames>>
X<строки; C<\N{}>>
X<C<\N{}>; экранирующая последовательность для именованного кодирования символа>

Некоторые символы Юникода имеют имена и эти имена часто проще прочесть, чем
номер Юникода. Используйте прагму C<charnames>, чтобы задействовать их, и
экранирующую последовательность C<\N{}> для ссылок на них:

=begin programlisting

    use charnames ':full';
    use Test::More tests => 1;

    my $escaped_thorn = "\x{00FE}";
    my $named_thorn   = "\N{LATIN SMALL LETTER THORN}";

    is $escaped_thorn, $named_thorn,
        'Thorn equivalence check';

=end programlisting

Вы можете использовать формы C<\x{}> и C<\N{}> внутри регулярных выражений
также, как и в любом другом месте, где разрешено использовать строку или символ.

=head3 Неявные Преобразования

Большая часть проблем с Юникодом в Perl возникает из-за того, что строка должна
быть или последовательностью октетов или последовательностью символов. Perl
позволяет комбинировать эти типы с использованием неявных преобразований. Когда
подобные преобразования ошибочны, они редко являются I<явно> ошибочными.

Когда Perl объединяет последовательность октетов с последовательностью символов
Юникода, он неявно декодирует последовательность октетов, используя кодировку
Latin-1. Результирующая строка будет содержать символы Юникода. При печати
символов Юникода, Perl закодирует строки, используя UTF-8, поскольку Latin-1 не
может представлять полный набор символов Unicode -- Latin-1 является
подмножеством UTF-8.

Эта асимметрия приводит к тому, что Юникод строки закодированны как UTF-8 для
вывода и декодированы как Latin-1 на вводе.

Хуже того, когда текст содержит только Английские буквы без акцентов, проблема
скрыта, так как обе кодировки имеют одинаковое представление символов.

=begin programlisting

    my $hello    = "Hello, ";
    my $greeting = $hello . $name;

=end programlisting

Если C<$name> содержит Английское имя, такое как I<Alice> вы никогда не заметите
проблемы, поскольку представление Latin-1 совпадает с UTF-8. Если C<$name>
содержит такое имя, как I<JosE<eacute>>, C<$name> может содержать несколько
возможных значений:

=over 4

=item *

C<$name> содержит четыре Юникод символа.

=item *

C<$name> содержит четыре Latin-1 октета, представляющие четыре Юникод символа.

=item *

C<$name> содержит пять UTF-8 октетов, представляющие четыре Юникод символа.

=back

Литеральная строка имеет несколько возможных сценариев:

=over 4

=item * Это ASCII литеральная строка и содержит октеты.

=begin programlisting

    my $hello = "Hello, ";

=end programlisting

=item * Это Latin-1 литеральная строка без явно указанной кодировки и содержащая
октеты.

=begin programlisting

    my $hello = "E<iexcl>Hola, ";

=end programlisting

Литеральная строка содержит октеты.

=item * Это не-ASCII литеральная строка с действующими прагмами <utf8> или
C<encoding> и содержит Юникод символы.

=begin programlisting

    use utf8;
    my $hello = "KuirabE<aacute>, ";

=end programlisting

=back

Если обе C<$hello> и C<$name> являются Юникод строками, объединение произведёт
ещё одну Юникод строку.

Если обе строки потоки октетов, Perl объединит их в новую строку октетов. Если
оба значения октеты одной и той же кодировки: обе Latin-1, например, то
объединение сработает корректно. Если у октетов не совпадает кодировка, например
конкатенация добавляет UTF-8 данные к данным Latin-1, тогда результирующая
последовательность октетов не имеет смысла I<ни в одной> кодировке. Это может
случиться, если пользователь ввёл имя как UTF-8 данные, а приветствие было
Latin-1 литеральной строкой, но программа не декодировала ни в одну из них.

Если только одно значение является Юникод строкой, Perl декодирует другую как
Latin-1 данные. Если это некорректная кодировка, результирующие Юникод символы
будут неправильными. Например, если пользовательский ввод был UTF-8 данными и
литеральная строка была Юникод строкой, имя будет некорректно декодировано в
пять Юникод символов в виде I<JosE<Atilde>E<copy>> (I<так>) вместо
I<JosE<eacute>>, поскольку UTF-8 данные значат нечто другое, когда декодированы
как Latin-1 данные.

Смотрите C<perldoc perluniintro> для более детального объяснения Юникода,
кодировок и как эффективно управлять Юникодом во всех ваших программах, смотрите
ответ Тома Кристьянсена (Tom Christiansen) на вопрос "Почему Современный Perl
избегает UTF-8 по умолчанию?
U<http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default/6163129#6163129>>.

=begin sidebar

X<C<unicode_strings>>
X<прагмы; C<feature>>

Perl 5.12 добавил возможность, C<unicode_strings>, которая включает Юникод
семантику для всех строковых операций внутри её области видимости. Perl 5.14
улучшил эту возможность; если вы работаете с Юникодом в Perl, имеет смысл
обновиться по крайне мере до Perl 5.14.

=end sidebar

=head2 Числа

X<числа>
X<целые>
X<значения с плавающей запятой>

Perl поддерживает числа одновременно и как целые, и как значения с плавающей
запятой. Вы можете представлять их как в научной нотации, так и двоичной,
восьмеричной и шестнадцатеричной форме:

=begin programlisting

    my $integer   = 42;
    my $float     = 0.007;
    my $sci_float = 1.02e14;
    my $binary    = B<0b>101010;
    my $octal     = B<0>52;
    my $hex       = B<0x>20;

=end programlisting

X<числа; префиксы представления>
X<C<0b>>
X<C<0>>
X<C<0x>>

Выделенные символы - это числовые префиксы для двоичной, восьмеричной и
шестнадцатеричной форм соответственно. Будьте внимательны, лидирующий ноль для
целого числа I<всегда> означает восьмеричную форму.

X<числа; разделитель подчёркивание>
X<подчёркивание>

=begin tip Когда 1.99 + 1.99 равняется 4

Даже несмотря на то, что вы можете явно записывать значения с плавающей запятой
в Perl 5 с высокой точностью, Perl 5 хранит их внутренне в бинарном формате.
Эта форма иногда бывает неточна; уточните детали в C<perldoc perlnumber>.

=end tip

Вы не можете использовать запятые для отделения тысяч в записи числа, чтобы
парсер не интерпретировал запятую, как оператор запятой. Вместо этого нужно
использовать подчёркивание в записи числа. Парсер рассматривает его как
невидимый символ; зато читатели вашего кода вероятно нет. Эти записи
эквивалентны:

=begin programlisting

    my $billion = 1000000000;
    my $billion = 1_000_000_000;
    my $billion = 10_0_00_00_0_0_0;

=end programlisting

Используйте наиболее читаемую альтернативу.

X<C<Scalar::Util>>
X<C<looks_like_number()>>

Из-за преобразований типа (L<coercion>), Perl программисту редко требуется
заботиться о конвертировании текста, прочитанного извне программы в числа. Perl
будет рассматривать всё, что похоже на число I<как> число в числовом контексте.
В редких случаях, когда вам нужно знать выглядит ли что-либо как число для Perl,
используйте функцию C<looks_like_number> из базового модуля C<Scalar::Util>. Эта
функция возвращает истину если Perl считает, что переданный аргумент числовой.

X<C<Regexp::Common>>

Модуль C<Regexp::Common> со CPAN предоставляет несколько хорошо протестированных
регулярных выражений для идентификации более специфичных корректных I<типов>
(натуральное число, целое число, значение с плавающей запятой) или численные
значения.

=head2 Undef

X<C<undef>>

Значение C<undef> в Perl 5 представляет не присвоенное, неопределённое и
неизвестное значение.
Объявленные, но неопределённые скалярные переменные содержат C<undef>:

=begin programlisting

    my $name = undef;   # необязательное присвоение
    my $rank;           # также содержит undef

=end programlisting

X<C<undef>; преобразование типа>

C<undef> вычисляется как ложь в логическом контексте. Вычисление C<undef> в
строковом контексте -- таком как интерполяция его в строку -- приводит к
генерации предупреждения C<не инициализированное значение>:

=begin programlisting

    my $undefined;
    my $defined = $undefined . '... and so forth';

=end programlisting

... выдаёт:

=begin screen

    Use of uninitialized value $undefined in
    concatenation (.) or string...

=end screen

X<встроенные; C<defined>>

Встроенная функция C<defined> возвращает истинное значение, если её операнд
выражается в определённое значение (что угодно кроме C<undef>):

=begin programlisting

    my $status = 'страдаю от холода';

    say B<defined> $status;  # 1, что является истинным значением
    say B<defined> undef;    # пустая строка; ложное значение

=end programlisting

=head2 Пустой список

X<пустой список>
X<C<()>; пустой список>

Когда применяется с правой стороны присвоения, конструкция C<()> представляет
пустой список. В скалярном контексте это вычисляется в C<undef>. В списочном
контексте это пустой список. Когда применяется на левой стороне присвоения,
конструкция C<()> определяет списочный контекст. Для подсчёта числа элементов,
возвращённых из выражения в списочном контексте без использования временной
переменной используйте выражение (L<idioms>):

=begin programlisting

    my $count = B<()> = get_all_clown_hats();

=end programlisting

Благодаря правой ассоциативности (L<associativity>) оператора присвоения, Perl
сначала вычисляет второе присвоение, вызывая C<get_all_clown_hats()> в списочном
контексте. Это возвращает список.

Присвоение к пустому списку выкидывает все значения из списка, но поскольку
присвоение происходит в скалярном контексте, то это выражается в число элементов
на правой стороне выражения. В результате C<$count> содержит число элементов в
списке возвращённом из C<get_all_clown_hats()>.

Если сейчас вы находите подобную концепцию смущающей, в этом нет ничего
страшного. Как только вы поймёте как фундаментальные возможности Perl стыкуются
друг с другом на практике, это обретёт чёткий смысл.

=head2 Списки

X<списки>

Список - это группа, разделённая запятой из одного или нескольких выражений.
Списки могут появляться в исходном коде непосредственно как значения:

=begin programlisting

    my @first_fibs = (1, 1, 2, 3, 5, 8, 13, 21);

=end programlisting

... результат присвоения:

=begin programlisting

    my ($package, $filename, $line) = caller();

=end programlisting

... или как список выражений:

=begin programlisting

    say name(), ' => ', age();

=end programlisting

Скобки не I<создают> списки. Список создаёт оператор запятая. Там где скобки
присутствуют, в этих примерах они группируют выражения для изменения их
I<порядка> (L<precedence>).

X<операторы; диапазон>
X<операторы; C<..>>
X<C<..>; оператор диапазона>

Используйте оператор диапазона для создания списка литералов в компактной форме:

=begin programlisting

    my @chars = 'a' .. 'z';
    my @count = 13 .. 27;

=end programlisting

X<операторы; C<qw()>>
X<C<qw()>; оператор взятия слов в кавычки>

Используйте оператор C<qw()> для разделения символьной строки по пробелам для
создания списка строк:

=begin programlisting

    my @stooges = qw( Larry Curly Moe Shemp Joey Kenny );

=end programlisting

=begin tip Пожалуйста, без комментариев

Perl выдаст предупреждение, если C<qw()> содержит запятые или символ комментария
(C<#>), не сколько потому, что они редко встречаются в C<qw()>, а главным
образом потому, что их наличие обычно указывает на недосмотр.

=end tip

Список может быть (и часто является) результатом выражения, но эти списки не
отображаются явно в исходном коде.

Списки и массивы неравнозначны в Perl. Списки - это значения. Массивы - это
контейнеры. Вы можете сохранить список в массиве и можете преобразовать массив в
список, но это разные сущности. Например, индексация в массиве может
происходить как в скалярном контексте (для одного элемента), так и в списочном
контексте (для группы):

=begin programlisting

    # пока не волнуйтесь о деталях
    sub context
    {
        my $context = wantarray();

        say defined $context
             ? $context
                 ? 'list'
                 : 'scalar'
             : 'void';
        return 0;
    }

    my @list_slice  = (1, 2, 3)[context()];
    my @array_slice = @list_slice[context()];
    my $array_index = $array_slice[context()];

    say context(); # списочный контекст
    context();     # пустой контекст

=end programlisting
