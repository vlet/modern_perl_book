=encoding utf8

=head1 Неявные Идеи

Z<implicit_ideas>

Контекст это единственное лингвистическое сокращение в Perl. Программисты,
которые понимают эти сокращения могут с первого взгляда на код мгновенно понять
его наиболее важные характеристики. Другая важная лингвистическая особенность -
это Perl эквивалент местоимения.

=head2 Скалярная переменная по умолчанию

Z<default_scalar_variable>

X<переменные по умолчанию; скаляр>
X<переменные по умолчанию; C<$_>>
X<< переменные; C<$_> >>
X<< C<$_>; скалярная переменная по умолчанию >>

I<Скалярная переменная по умолчанию> (также называемая I<актуальная
переменная>), C<$_>, наиболее заметная в своём I<отсутствии>: многие встроенные
операторы Perl работают с содержимым C<$_> в случае отсутствия явной переменной.
Вы по-прежнему можете использовать C<$_> как переменную, но в этом часто нет
необходимости.

X<встроенные; C<chomp>>
X<встроенные; C<chr>>
X<встроенные; C<ord>>
X<встроенные; C<lc>>
X<встроенные; C<length>>
X<встроенные; C<reverse>>
X<встроенные; C<uc>>

Многие скалярные операторы Perl (включая C<chr>, C<ord>, C<lc>, C<length>,
C<reverse>, и C<uc>) работают со скалярной переменной по умолчанию, если вы не
предоставили им альтернативы. Например, встроенная функция C<chomp> удалит
любую завершающую последовательность перевода строки своего операндаN<смотрите
C<perldoc -f chomp> и C<$/> для более точных деталей её поведения.>:

=begin programlisting

    my $uncle = "Стёпа\n";
    chomp $uncle;
    say "'$uncle'";

=end programlisting

C<$_> выполняет ту же функцию в Perl, что и местоимение I<это> в Русском языке.
Без явной переменной, C<chomp> удалит завершающую последовательность перевода
строки в C<$_>. Perl понимает то, что вы имели ввиду, когда сказали "C<chomp>";
Perl всегда "откусит" I<это>, поэтому эти две строки кода эквивалентны:

=begin programlisting

    chomp $_;
    chomp;

=end programlisting

X<встроенные; C<say>>
X<встроенные; C<print>>

Аналогично, C<say> и C<print> оперируют с C<$_> при отсутствии других
аргументов:

=begin programlisting

    print;  # напечатает $_ в текущий дескриптор файла
    say;    # напечатает "$_\n" в текущий дескриптор фала

=end programlisting

X<C<s///>; оператор замены>
X<C<m//>; оператор совпадения>
X<C<tr//>; оператор транслитерации>

Средства регулярных выражений в Perl (L<regex>) по умолчанию используют C<$_>
для поиска совпадений, замены и транслитерации:

=begin programlisting

    $_ = 'My name is Paquito';
    say if /My name is/;

    s/Paquito/Paquita/;

    tr/A-Z/a-z/;
    say;

=end programlisting

X<встроенные; C<for>>

Директивы цикла в Perl (L<looping_directives>) по умолчанию используют C<$_>
как переменную итерации. Рассмотрим C<for>, проходящий по списку:

=begin programlisting

    say "#B<$_>" for 1 .. 10;

    for (1 .. 10)
    {
        say "#B<$_>";
    }

=end programlisting

X<встроенные; C<while>>

... или C<while>:

=begin programlisting

    while (<STDIN>)
    {
        chomp;
        say scalar reverse;
    }

=end programlisting

X<встроенные; C<map>>

... или C<map> преобразующий список:

=begin programlisting

    my @squares = map { B<$_> * B<$_> } 1 .. 10;
    say for @squares;

=end programlisting

X<встроенные; C<grep>>

... или C<grep> фильтрующий список:

=begin programlisting

    say 'Время для завтрака!'
        if grep { /блинчики/ } @pantry;

=end programlisting

И обычная речь становится путанной, когда у вас слишком много местоимений и
антецедентов. Вы должны позаботиться о смешанном использовании C<$_> явно или
неявно. Непредусмотрительное одновременное использование C<$_> может привести к
тому, что одна часть кода молча переписывает значение, записанное другой. Если
вы пишите функцию, которая использует C<$_>, вы можете разрушить, используемую
вызывающей функцией, переменную C<$_>.

Начиная с Perl 5.10, вы можете объявлять C<$_> как лексическую переменную
(L<lexical_scope>), чтобы избежать этого разрушительного поведения:

=begin programlisting

    while (<STDIN>)
    {
        chomp;

        # ПЛОХОЙ ПРИМЕР
        my $munged = calculate_value( $_ );
        say "Оригинальное: $_";
        say "Распознанное: $munged";
    }

=end programlisting

Если C<calculate_value()> или любая другая функция изменяет C<$_>, это изменение
сохранится в течении этой итерации цикла. Добавление объявления C<my>
предотвращает порчу существующего экземпляра C<$_>:

=begin programlisting

    while (my $_ = <STDIN>)
    {
        ...
    }

=end programlisting

Разумеется использование именованной лексемы может быть столь же ясным:

=begin programlisting

    while (my $line = <STDIN>)
    {
        ...
    }

=end programlisting

Используйте C<$_> также как слово "это" в обычном письме: экономно, в небольших
и вполне определённых пределах.

=begin tip Оператор C<...>

X<встроенные; C<...>>

Perl 5.12 ввёл оператор тройной точки (C<...>) в качестве пометки места для
кода, который вы намереваетесь написать позже. Perl распознает его как
обычный оператор, но вызовет исключение, что вы пытаетесь запустить ещё
нереализованный код, при попытке его запуска. Смотрите C<perldoc perlop> для
деталей.

=end tip

=head2 Переменная массива по умолчанию

Z<default_array_variables>

X<переменные по умолчанию; массив>
X<переменные по умолчанию; C<@_>>
X<переменные; C<@_>>
X<C<@_>>

Perl также имеет две неявных переменных массивов. Perl передаёт аргументы
функциям (L<functions>) в массиве называемом C<@_>. Операции работы над массивом
(L<arrays>) внутри функций воздействуют на этот массив по умолчанию, поэтому
эти два примера кода эквивалентны:

=begin programlisting

    sub foo
    {
        my $arg = shift;
        ...
    }

    sub foo_explicit_args
    {
        my $arg = shift @_;
        ...
    }

=end programlisting

X<встроенные; C<shift>>
X<встроенные; C<pop>>

Также как C<$_> соответствует местоимению I<это>, так и C<@_> соответствует
местоимению I<эти>. В I<отличии> от C<$_>, Perl автоматически локализует C<@_>,
когда вы вызываете другие функции. Встроенные функции C<shift> и C<pop>
оперируют над C<@_>, если отсутствуют другие операнды.

X<переменные по умолчанию; C<@ARGV>>
X<переменные; C<@ARGV>>
X<C<@ARGV>>

Вне всех функций переменная по умолчанию C<@ARGV> содержит аргументы командной
строки программы. Операции Perl над массивом (включая C<shift> и C<pop>)
работают и с C<@ARGV> явно вне функций. Вы не можете использовать C<@_>, если
имеете ввиду C<@ARGV>.

=begin tip C<readline>

X<встроенные; C<readline>>
X<встроенные; C<glob>>

Оператор Perl C<< <$fh> >> это тоже самое, что и встроенная функция C<readline>.
C<readline $fh> делает то же самое, что и C<< <$fh> >>. Начиная с Perl 5.10,
просто C<readline> ведёт себя также как и C<< <> >>, поэтому вы можете
использовать C<readline> везде. По историческим причинам, C<< <> >> по-прежнему
очень распространён, но подумайте об использовании C<readline> как более
читаемой альтернативе. Вы возможно предпочтёте C<glob '*.html'> вместо
C<< <*.html> >>, правильно? Тут та же идея.

=end tip

X<нулевой файловый дескриптор>

C<ARGV> имеет один специальный случай. Если вы читаете из нулевого файлового
дескриптора C<< <> >>, Perl будет рассматривать каждый элемент в C<@ARGV>, как
I<имя> файла для открытия на чтение. (Если C<@ARGV> пустой, Perl будет читать
со стандартного ввода.) Это неявное поведение C<@ARGV> полезно при написании
коротких программ, как этот фильтр командной строки, который переворачивает
данные, получаемые со входа:

=begin programlisting

    while (<>)
    {
        chomp;
        say scalar reverse;
    }

=end programlisting

Зачем нужен C<scalar>? C<say> подразумевает списочный контекст для своих
операндов. C<reverse> передаёт свой контекст своим операндам, рассматривая их
как список в списочном контексте и соединёнными строками в скалярном контексте.
Если поведение C<reverse> кажется вам странным, то ваши инстинкты вас не
подводят. Perl 5 действительно должен иметь отдельный "reverse для строки" и
"reverse для списка".

Если вы запустите его со списком файлов:

=begin screen

    $ B<perl reverse_lines.pl encrypted/*.txt>

=end screen

... результатом будет один длинный поток вывода. Без аргументов вы можете
выдать свой собственный стандартный ввод, взяв его из вывода другой программы,
или непосредственно введя его. И всё же Perl хорош не только для маленьких
программ командной строки....
