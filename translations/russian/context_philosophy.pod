=encoding utf8

=head1 Контекст

Z<context_philosophy>

X<контекст>

В разговорных языках значение слова или фразы может зависеть от того как
вы используете их; местный I<контекст> помогает прояснить намерение. Например,
неподходящее использование множественного числа в "Пожалуйста, дайте мне один
гамбургеры!"N<Множественное число существительного отличается от количества.>
звучит неправильно, также как и неверный род в "милый кошка"N<прилагательное
мужского рода, но существительное женского рода.> вызовут улыбку у носителя
языка. Возьмите местоимение "вы" или существительное "метро", которые могут
быть в единственном или множественном числе в зависимости от контекста.

Контекст в Perl схож. Он принимает во внимание количество также, как и тип
данных. Perl с радостью попытается обеспечить именно то, что вы просили -- при
условии, что вы выбрали подходящий контекст.

Некоторые операции в Perl производят различные действия, если вы запрашиваете
ноль, один или несколько результатов. Специфичная конструкция в Perl может
делать что-то отличное в том случае, если вы напишите "Сделай это, но меня не
волнует результат", в сравнении с "Сделай это и я ожидаю получить несколько
результатов". Другие операции позволяют вам указать ожидаете ли вы работать
с численными данными, текстовыми данными или со значениями истина или ложь.

Контекст может оказаться сложным, если вы пытаетесь писать или читать Perl код,
как серию одиночных выражений, извлечённых из их окружения. И даже хлопнуть
себя по лбу после продолжительного времени отладки, когда вдруг обнаружите, что
ваше предположение о контексте было ошибочным. Если бы вместо этого вы были бы
осведомлены о контексте, ваш код стал бы правильнее -- и чище, и гибче, и более
кратким.

=head2 Пустой, Скалярный и Списочный Контекст

Z<amount_context>

X<контекст; количество>
X<количественный контекст>

I<Количественный контекст> управляет тем I<как много> элементов вы ожидаете от
операции. Согласование числа глагола и подлежащего в Английском языке - это
самый близкий аналог. Даже не зная формального определение этого
лингвистического принципа, вы вероятно видите ошибку в предложении "Perl
являются прикольным языком". В Perl число элементов, которые вы запрашиваете,
определяет то, сколько вы их получите.

X<пустой контекст>
X<контекст; пустой>

Предположим у вас есть функция (L<functions>) называемая C<find_chores()>,
которая сортирует ваш семейный список запланированных дел в порядке приоритета
задачи. Это означает то, как вы вызовите функцию, определит то, что она
выведет. У вас может не быть времени сделать уборку, в этом случае вызов функции
это просто попытка выглядеть трудолюбивым.  Возможно у вас достаточно времени,
чтобы сделать одно дело или у вас взрыв энергии в свободный выходной и желание
сделать как можно больше.

Если вы просто вызовите функцию и не собираетесь использовать, возвращаемый ею
результат, то вы вызываете функцию в I<пустом контексте>:

=begin programlisting

    find_chores();

=end programlisting

X<контекст; скаляр>
X<скалярный контекст>

Присвоение возвращаемого функцией значения одиночному элементу (L<scalars>),
вычисляет функцию в I<скалярном контексте>:

=begin programlisting

    my $single_result = find_chores();

=end programlisting

X<списочный контекст>
X<контекст; список>

Присвоение результатов вызова функции массиву (L<arrays>) или списку, или
использование его в списке, вычисляет функцию в I<списочном контексте>:

=begin programlisting

    my @all_results             = find_chores();
    my ($single_element, @rest) = find_chores();
    process_list_of_results( find_chores() );

=end programlisting

Скобки во второй строчке предыдущего примера группируют объявление двух
переменных (L<lexical_scope>) так, что присвоение произойдёт так, как вы
ожидаете. Если бы C<@rest> не использовался, вы также совершенно правильно
написали бы:

=begin programlisting

    my B<(>$single_elementB<)>   = find_chores();

=end programlisting


... в таком случае скобки дают подсказку анализатору Perl 5, что вы имеете ввиду
списочный контекст для присвоения, даже если присваиваете только одному элементу
списка. Это тонкость, но вы теперь знаете о ней, разница в количественном
контексте между этими двумя выражениями должна быть очевидна:

=begin programlisting

    my $scalar_context = find_chores();
    my B<(>$list_contextB<)> = find_chores();

=end programlisting

Вычисление функции или выражения -- за исключением присвоения -- в списочном
контексте может приводить к путанице. Списки распространяют списочный контекст
на выражения, которые они содержат. Оба этих вызова  C<find_chores()> происходят
в списочном контексте:

=begin programlisting

    process_list_of_results( find_chores() );

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => find_chores(), # ОЙ!
    );

=end programlisting

X<встроенные; C<скаляр>>

Последний пример часто удивляет новичков программистов, при инициализации хэша
(L<hashes>) со списком значений устанавливается списочный контекст на
C<find_chores>. Используйте оператор C<scalar>, чтобы навязать скалярный
контекст:

=begin programlisting

    my %results =
    (
        cheap_operation     => $cheap_results,
        expensive_operation => B<scalar> find_chores(),
    );

=end programlisting

Почему контекст имеет значение? Функции, понимающие контекст, могут проверять
в каком контексте они вызваны и решать какое количество работы им потребуется
выполнить. В пустом контексте C<find_chores()> может вполне законно ни делать
ничего. В скалярном контексте она может найти самую важную задачу. В списочном
контексте она должна отсортировать и вернуть весь список целиком.

=head2 Числовой, Строковой и Логический Контекст

Z<value_contexts>

X<контекст значения>
X<контекст; значение>

Другой контекст Perl -- I<контекст значения> -- определяет как Perl
интерпретирует данные. Вы уже возможно заметили, что Perl гибок в вопросе
определения число у нас или строка, и конвертирования из одного в другое, если
вам это требуется. В обмен на отсутствие явного объявление (или по-крайне мере
не отслеживание) какой I<тип> данных содержится в переменной или выводе функции,
контекст типа в Perl даёт подсказки, которые говорят компилятору как
воспринимать данные.

X<встроенные; C<eq>>

Perl приводит значения к определённому надлежащему типу (L<coercion>), в
зависимости от того, какой оператор вы используете. Например, оператор C<eq>
проверяет, что строки содержат одинаковую информацию I<как строки>:

=begin programlisting

    say "Катастрофическая крипто ошибка!" if $alice eq $bob;

=end programlisting

У вас возможно есть проблемный опыт, когда вы I<знаете>, что строки разные, но
они по-прежнему оказываются равными:

=begin programlisting

    my $alice = 'Алиса';
    say "Катастрофическая крипто ошибка!" if $alice == 'Боб';

=end programlisting

X<строковой контекст>
X<числовой контекст>
X<контекст; строка>
X<контекст; число>

X<встроенные; C<==>>

Оператор C<eq> воспринимает свои операнды как строки, принудительно вводя
I<строковой контекст> для них. Оператор C<==> навязывает I<числовой контекст>.
В числовом контексте обе строки вычисляются в C<0> (L<numeric_coercion>).
Убедитесь, что используете правильный оператор для того типа контекста,
который вам нужен.

X<логический контекст>
X<контекст; логический>

I<Логический контекст> встречается, когда вы используете значение в условном
операторе. В предыдущем примере C<if> вычисляет результат операторов C<eq> и
C<==> в логическом контексте.

X<контекст; явный>

В редких случаях вам может потребоваться принудительно установить контекст,
когда не существует подходящего для этих целей оператора. Чтобы установить
числовой контекст, прибавьте ноль к переменной. Для установки строкового
контекста, присоедините к переменной пустую строку. Чтобы установить
логический контекст, добавьте двойной оператор отрицания:

=begin programlisting

    my $numeric_x =  0 + $x;  # принудительный числовой контекст
    my $stringy_x = '' . $x;  # принудительный строковой контекст
    my $boolean_x =    !!$x;  # принудительный логический контекст

=end programlisting

Контекст типа определить значительно проще, чем количественный контекст. Как
только вы узнаете какой контекст дают различные операторы (L<operator_types>),
вы редко будете делать ошибки.
