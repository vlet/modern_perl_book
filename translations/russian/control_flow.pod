=encoding utf8

=head1 Порядок выполнения

Z<control_flow>

X<Порядок выполнения>

I<Порядок выполнения> в базовом Perl прямолинейный. Выполнение программы
начинается от начала (первая строка выполняемого файла) и продолжается до конца:

=begin programlisting

    say 'В начале';
    say 'В середине';
    say 'В конце';

=end programlisting

X<директивы порядка выполнения>

I<Директивы порядка выполнения> в Perl изменяют порядок выполнения -- что
следующее произойдёт в программе -- в зависимости от значения их выражений.

=head2 Директивы Ветвления

X<директивы порядка выполнения; C<if>>

Директива C<if> выполняет связанное действие, только если условное выражение
вычисляется в значение I<истины>:

=begin programlisting

    say 'Привет, Вася!' if $name eq 'Вася';

=end programlisting

Эта постфиксная форма удобна для простых выражений. Блоковая форма объединяет
несколько выражение в единый элемент:

=begin programlisting

    if ($name eq 'Вася')
    {
        say 'Привет, Вася!';
        found_vasya();
    }

=end programlisting

В то время, как блоковая форма требует окружающих скобок вокруг условия,
постфиксная форма их не требует.

Условное выражение может состоять из нескольких подвыражений, которое
вычисляется в одно выражение верхнего уровня:

=begin programlisting

    if ($name eq 'Вася' && not greeted_vasya())
    {
        say 'Привет, Вася!';
        found_vasya();
    }

=end programlisting

В постфиксной форме добавление скобок может прояснить смысл в ущерб визуальной
чистоте:

=begin programlisting

    greet_bob() if ($name eq 'Bob' && not greeted_bob());

=end programlisting

X<директивы порядка выполнения; C<unless>>

Директива C<unless> - это отрицательная форма C<if>. Perl выполнит действие,
когда условное выражение вычисляется в I<ложь>:

=begin programlisting

    say "Ты не Вася!" unless $name eq 'Вася';

=end programlisting

Так же как и C<if>, C<unless> также имеет блоковую форму, хотя многие
программисты стараются её избегать, так как сразу становиться трудно прочитать
её со сложными выражениями:

=begin programlisting

    unless (is_leap_year() and is_full_moon())
    {
        frolic();
        gambol();
    }

=end programlisting

C<unless> отлично работает с постфиксными условиями, особенно для для проверки
параметров в функциях (L<postfix_parameter_validation>):

=begin programlisting

    sub frolic
    {
        return unless @_;

        for my $chant (@_) { ... }
    }

=end programlisting

X<директивы порядка выполнения; C<else>>

Блоковые формы C<if> и C<unless> обе работают с директивой C<else>, которая даёт
код для выполнения, когда условное выражение не вычислено в истину (для C<if>)
или ложь (для C<unless>):

=begin programlisting

    if ($name eq 'Вася')
    {
        say 'Привет, Вася!';
        greet_user();
    }
    else
    {
        say "Я тебя не знаю.";
        shun_user();
    }

=end programlisting

Блоки C<else> позволяют вам переписывать условия C<if> на C<unless> и обратно:

=begin programlisting

    unless ($name eq 'Вася')
    {
        say "Я тебя не знаю.";
        shun_user();
    }
    else
    {
        say 'Привет, Боб!';
        greet_user();
    }

=end programlisting

Однако, получающееся двойное отрицание, при использовании C<unless> вместе с
блоком C<else>, может сбить с толку. Этот пример возможно единственное место,
где вы это вообще видите.

Раз Perl предоставляет оба C<if> и C<unless>, чтобы дать вам возможность
выражать ваши условия в наиболее читаемом виде, вы можете выбирать между
позитивным и негативным условным оператором:

=begin programlisting

    if ($name B<ne> 'Вася')
    {
        say "Я не знаю тебя.";
        shun_user();
    }
    else
    {
        say 'Привет, Вася!';
        greet_user();
    }

=end programlisting

... хотя двойное отрицание, получившееся с наличием блока C<else>, подсказывает
перевернуть условие.

X<директивы порядка выполнения; C<elsif>>

Одна или больше директив C<elsif> может следовать за блоком C<if> и может
предшествовать одиночному C<else>:

=begin programlisting

    if ($name eq 'Вася')
    {
        say 'Привет, Вася!';
        greet_user();
    }
    elsif ($name eq 'Петя')
    {
        say 'Привет, Петя!';
        greet_user();
    }
    else
    {
        say "Вы не мой дядя.";
        shun_user();
    }

=end programlisting

Цепочка C<unless> также может использовать C<elsif> блокN<Удачи в расшифровке
такого кода!>. Не существует C<elseunless>.

Запись C<else if> является синтаксической ошибкойN<Ларри предпочитает C<elsif>
по эстетическим соображениям, также как и в языке программирования Ada>

=begin programlisting

    if ($name eq 'Ринат')
    {
        say 'Привет, кузен!';
    }

    # warning; syntax error
    else if ($name eq 'Кристина')
    {
        say 'Привет, братаниха!';
    }

=end programlisting

=head2 Тернарный Условный Оператор

X<тернарное условие>
X<директивы порядка выполнения; тернарное условие>

I<Тернарный условынй оператор> - это оператор, вычисляющий условное выражение и
возвращающий одну из двух альтернатив:

=begin programlisting

    my $time_suffix = after_noon($time)
                    ? 'день'
                    : 'утро';

=end programlisting

Условное выражение предшествует знаку вопроса (C<?>) и символ двоеточия (C<:>)
разделяет альтернативы. Альтернативы - это выражения произвольной сложности --
включая другое тернарное условное выражение.

=begin sidebar

Интересный хоть и неочевидный приём - использовать тернарное условие для выбора
между альтернативными I<переменными>, а не только значениями:

=begin programlisting

    push @{ rand() > 0.5 ? \@red_team : \@blue_team },
        Player->new;

=end programlisting

Опять же, взвешивайте выгоду от ясности, против достоинства краткости.

=end sidebar

=head3 Сокращённое вычисление

Z<short_circuiting>
X<сокращённое вычисление>

Perl проявляет I<сокращённое вычисление>, когда он встречает сложные условные
выражения. Когда Perl может определить, что сложное выражение истинно или ложно
в целом без вычисления каждого подвыражения, он не выполняет последующие
подвыражения. Это станет ясно в следующем примере:

=begin programlisting

    say "Оба верны!" if ok( 1, 'первое подвыражение' )
                     && ok( 1, 'второе подвыражение' );

    done_testing();

=end programlisting

Возвращаемое значение C<ok()> (L<testing>) - это логическое значение, полученное
путём вычисления первого аргумента, поэтому этот код выведет:

=begin screen

    ok 1 - первое подвыражение
    ok 2 - второе подвыражение
    Оба верны!

=end screen

Когда первое подвыражение -- первый вызов C<ok> -- вычисляется в истинное
значение, Perl должен вычислить второе выражение. Если первое подвыражение было
вычислено как ложное значение, то нет необходимости вычислять следующее
подвыражение, так как выражение в целом уже не будет истинным:

=begin programlisting

    say "Оба верны!" if ok( 0, 'первое подвыражение' )
                     && ok( 1, 'второе подвыражение' );

=end programlisting

Этот пример выведет:

=begin screen

    not ok 1 - первое подвыражение

=end screen

Даже хотя второе выражение очевидно истинно, Perl никогда не вычисляет его.
Такое же сокращённое вычисление очевидно есть и для операций с логическим ИЛИ:

=begin programlisting

    say "Одно из двух верно!" if ok( 1, 'первое подвыражение' )
                              || ok( 1, 'второе подвыражение' );

=end programlisting

Этот пример выведет:

=begin screen

    ok 1 - первое подвыражение
    Одно из двух верно!

=end screen

С вычисленным истинным значением первого подвыражения, Perl может избежать
необходимости в вычислении второго подвыражения. Если первое подвыражение было
ложным, то вычисление второго подвыражения определило бы результат вычисления
всего выражения.

Кроме возможности избежать потенциально дорогостоящие вычисления, сокращённое
вычисление помогает избежать ошибок и предупреждений, как в случае, когда
использование неопределённого значения может привести к выводу предупреждения:

=begin programlisting

    my $bbq;
    if (defined $bbq and $bbq eq 'brisket') { ... }

=end programlisting

=head2 Контекст для Условных Директив

X<контекст; условия>
X<булевы типы; истина>
X<истина>
X<ложь>

Условные директивы--C<if>, C<unless>, и тернарный условный оператор--все
вычисляют выражение в логическом контексте (L<context_philosophy>). Поскольку
операторы сравнения, такие как C<eq>, C<==>, C<ne> и C<!=>, всегда возвращают
логический результат при вычислении, Perl преобразует результаты выражения--
включая переменные и значения--к логическому типу.

В Perl 5 нет ни единственного значение истины, ни единственного значения ложь.
Любое число, которое равно 0 является ложью. Это включает C<0>, C<0.0>, C<0e0>,
C<0x0> и так далее. Пустая строка (C<''>) и C<'0'> преобразуются в ложь, но
строки C<'0.0'>, C<'0e0'> и подобные -- уже нет. Строка C<'0 but true'>
преобразуется к 0 в числовом контексте, но становится истиной в логическом
контексте благодаря своему содержимому строки.

Пустой список и C<undef> оба преобразуются к значению ложь. Пустые массивы и
хэши, возвращающее число 0 в скалярном контексте, вычисляются в значение ложь в
логическом контексте. Массив, который содержит единственный элемент--даже
C<undef>--преобразуется к истине в логическом контексте. Хэш, который содержит
любые элементы--даже ключ и значение C<undef>--преобразуется к значению истины
в логическом контексте.

=begin tip Лучший Контроль Над Контекстом

X<CPAN; C<Want>>
X<прагмы; C<overloading>>

Модуль C<Want> со CPAN позволяет Вам определить логический контекст внутри
Ваших собственных функций. Базовая прагма C<overloading> (L<overloading>)
позволяет Вам указывать какой результат будут производить Ваши типы данных,
когда вычисляются в разных контекстах.

=end tip

=head2 Директивы Циклов

Z<looping_directives>

X<директивы циклов; C<for>>
X<директивы циклов; C<foreach>>

Perl предоставляет несколько директив для циклов и итераций. I<foreach>-стиль
циклов вычисляет выражение, которое возвращает список и выполняет оператор или
блок, пока не исчерпает весь список:

=begin programlisting

    foreach (1 .. 10)
    {
        say "$_ * $_ = ", $_ * $_;
    }

=end programlisting

Этот пример использует оператор диапазона для создания списка целых чисел от
одного до десяти включительно. Директива C<foreach> проходит через него,
устанавливая актуальную переменную C<$_> (L<default_scalar_variable>) в
текущее значение на каждом шаге. Perl выполняет блок кода для каждого целого
числа и выводит квадрат числа.

=begin tip C<foreach> в сравнении с C<for>

X<встроенные; C<for>>
X<встроенные; C<foreach>>

Многие Perl программисты считают, что только цикл C<foreach> является
итеративным, но Perl рассматривает имена C<foreach> и C<for> равнозначными.
Последующий код определяет какой тип и поведение у цикла.

=end tip

Как C<if> и C<unless> эти циклы имеют постфиксную форму:

=begin programlisting

    say "$_ * $_ = ", $_ * $_ for 1 .. 10;

=end programlisting

Цикл C<for> может использовать выделенную переменную вместо переменной по
умолчанию:

=begin programlisting

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

Когда C<for> использует итеративную переменную, область видимости переменной
локализована внутри цикла. Perl будет устанавливать лексическую переменную в
значение каждого элемента при каждой итерации. Perl не будет модифицировать
актуальную переменную (C<$_>). Если вы определили лексическую переменную C<$i>
во внешней области видимости, то она останется нетронутой вне цикла:

=begin programlisting

    my $i = 'cow';

    for my $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'cow', 'Значение сохранилось во внешней области видимости' );

=end programlisting

Локализация происходит даже если вы не переопределяете итеративную переменную
как лексическуюN<... но I<следует> декларировать ваши итеративные переменные для
ограничения их области видимости.>:

=begin programlisting

    my $i = 'horse';

    for $i (1 .. 10)
    {
        say "$i * $i = ", $i * $i;
    }

    is( $i, 'horse', 'Значение сохранилось во внешней области видимости' );

=end programlisting

=head2 Итерация и Ссылка

X<итерация; ссылки>
X<ссылка>
X<ссылка; итерация>

Цикл C<for> создаёт I<ссылку> на переменную итерации в цикле так, что изменение
значения итератора модифицирует исходное значение:

=begin programlisting

    my @nums = 1 .. 10;

    $_ **= 2 for @nums;

    is( $nums[0], 1, '1 * 1 is 1' );
    is( $nums[1], 4, '2 * 2 is 4' );

    ...

    is( $nums[9], 100, '10 * 10 это 100' );

=end programlisting

Такое же создание ссылок происходит и при использовании блочного стиля цикла
C<for>:

=begin programlisting

    for my $num (@nums)
    {
        $num **= 2;
    }

=end programlisting

... в том числе и при итерации с актуальной переменной:

=begin programlisting

    for (@nums)
    {
        $_ **= 2;
    }

=end programlisting

Однако, Вы не сможете изменить значение I<константы>:

=begin programlisting

    for (qw( Huex Dewex Louid ))
    {
        $_++;
        say;
    }

=end programlisting

Вместо этого Perl выдаст исключение о попытке модификации значения доступного
только для чтения.

Вы можете иногда наблюдать использование C<for> с единственной скалярной
переменной, на которую ссылается актуальная переменная C<$_>:

=begin programlisting

    for ($user_input)
    {
        s/\A\s+/;       # убрать пробелы в начале
        s/\s+\z/;       # убрать пробелы в конце

        $_ = quotemeta; # экранировать спецсимволы
    }

=end programlisting

=head2 Итерация и область видимости

X<итерация; область видимости>
X<область видимости; итератор>
X<C<my $_>>
X<C<$_>; лексический>

Область видимости итератора при использовании актуальной переменной самый
частый источник недоразумений. Рассмотрим функцию C<topic_mangler()>, которая
изменяет C<$_> по запросу. Если код цикла вызывает функцию C<topic_mangler()>
без защиты C<$_>, веселье с отладкой кода Вам гарантированны:

=begin programlisting

    for (@values)
    {
        topic_mangler();
    }

    sub topic_mangler
    {
        s/foo/bar/;
    }

=end programlisting

Если Вы I<должны> использовать C<$_> вместо именованной переменной, сделайте
актуальную переменную лексической с помощью C<my $_>:

=begin programlisting

    sub topic_mangler
    {
        # было $_ = shift;
        B<my> $_ = shift;

        s/foo/bar/;
        s/baz/quux/;

        return $_;
    }

=end programlisting

Использование именованной переменной итерации также предотвращает появление
нежеланной ссылки через C<$_>.

=head2 Циклы в C-стиле

X<циклы; C<for>>

C-стиль I<цикла for> требует наличия условия итерации:

=begin programlisting

    for (my $i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

Вы должны явно присвоить значение переменной итерации в конструкции цикла, так
как подобный цикл не создаёт ни ссылки, ни привязки к актуальной переменной.  Но
все переменные, объявление внутри конструкции цикла, ограничены областью
видимости цикла, хотя при этом не происходит изоляции переменных объявленных вне
конструкции цикла:

=begin programlisting

    my $i = 'pig';

    for ($i = 0; $i <= 10; $i += 2)
    {
        say "$i * $i = ", $i * $i;
    }

    isnt( $i, 'pig', '$i переписано числом' );

=end programlisting

Конструкция цикла может состоять из трёх подвыражений. Первое подвыражение--
инициализирующая секция--выполняется только один раз перед запуском тела цикла.
Perl вычисляет второе подвыражение--условное сравнение--перед каждой итерацией
тела цикла. Если выражение истинное, то происходит итерация. Если выражение
становится ложным, итерации останавливаются. Последнее подвыражение выполняется
после каждой итерации тела цикла.

=begin programlisting

    for (
        # подвыражение инициализации цикла
        say 'Инициализация', my $i = 0;

        # подвыражение условного сравнения
        say "Итерация: $i" and $i < 10;

        # подвыражение завершения итерации
        say 'Увеличиваем ' . $i++
    )
    {
        say "$i * $i = ", $i * $i;
    }

=end programlisting

Обратите внимание на отсутствие точки с запятой после последнего подвыражения,
также как и на использование оператора запятой и низкопроритетного C<and>;
этот синтаксис на удивление привередлив. Когда это возможно, отдавайте
предпочтение C<foreach>-стилю циклов вместо C<for> циклов.

Все три подвыражения опциональны. Бесконечный цикл C<for> может быть таким:

=begin programlisting

    for (;;) { ... }

=end programlisting

=head2 While и Until

X<циклы; C<while>>

Цикл I<while> продолжается до тех пор пока условное выражение цикла не получит
ложное значение. Типичный бесконечный цикл выглядит так:

=begin programlisting

    while (1) { ... }

=end programlisting

В отличии от цикла C<foreach>-стиля, условие цикла C<while> не имеет
посторонних эффектов. Например, если  C<@values> имеет один или большее число
элементов, данный код также становится бесконечным циклом:

=begin programlisting

    while (@values)
    {
        say $values[0];
    }

=end programlisting

X<деструктивное обновление>

Чтобы предотвратить подобный бесконечный цикл C<while>, используйте
I<деструктивное обновление> массива C<@values> изменяющее массив с каждой
итерацией:

=begin programlisting

    while (@values)
    {
        my $value = shift @values;
        say $value;
    }

=end programlisting

Изменяя C<@values> внутри условия C<while> также сработает, но имеет некоторые
тонкости, относящиеся к истинности каждого значения.

=begin programlisting

    while (my $value = shift @values)
    {
        say $value;
    }

=end programlisting

Подобный цикл завершиться как только достигнет элемента, который вычисляется в
ложное значение, и не обязательно в тот момент, когда будет исчерпан весь
массив. Это может быть желаемое поведение, но может и стать сюрпризом для
новичков.

X<циклы; C<until>>

Цикл I<until> переворачивает смысл теста в цикле C<while>.
Итерации продолжаются до тех пор условное выражение является ложью:

=begin programlisting

    until ($finished_running)
    {
        ...
    }

=end programlisting

Каноническое использование цикла C<while> -- это итерация с получением данных
из файлового дескриптора:

=begin programlisting

    use autodie;

    open my $fh, '<', $file;

    while (<$fh>)
    {
        ...
    }

=end programlisting

Perl 5 интерпретирует этот цикл C<while> как если бы Вы написали:

=begin programlisting

    while (defined($_ = <$fh>))
    {
        ...
    }

=end programlisting

Без явного C<defined>, любая строка прочитанная из файлового дескриптора,
которая вычисляется в ложное значение--пустая строка или строка, которая
содержит только символ  C<0>--завершит цикл. Оператор C<readline>
(C<< <> >>) возвращает неопределённое значение только, когда он достигает
конца файла.

=begin tip C<chomp>'айте Ваши Строки

X<встроенные; C<chomp>>

Используйте встроенную функцию C<chomp> для удаления символов завершения
строки для каждой строки. Многие новички забывают об этом.

=end tip

C<while> и C<until> оба имеют постфиксную форму записи, как, например,
бесконечный цикл C<1 while 1;>. Любое одиночное выражение подходит для
постфиксного C<while> или C<until>, включая классический пример
"Привет, мир!" на 8-битных компьютерах ранних 1980-ых:

=begin programlisting

    print "Привет, мир!" while 1;

=end programlisting

Бесконечные циклы иногда очень полезны, чем может показаться поначалу,
особенно для циклов обработки событий в графических программах, интерпретаторах
или сетевых серверах:

=begin programlisting

    $server->dispatch_results() until $should_shutdown;

=end programlisting

X<циклы; C<do>>

Используйте блок C<do> для группировки нескольких выражений в единый элемент:

=begin programlisting

    do
    {
        say 'Как ваше имя?';
        my $name = <>;
        chomp $name;
        say "Привет, $name!" if $name;
    } until (eof);

=end programlisting

Блок C<do> обрабатывается как одиночное выражение, которое может состоять из
нескольких выражений. В отличии от формы блока C<while>, блок C<do> с
постфиксным C<while> или C<until> будет выполнен хотя бы один раз. Эта
конструкция встречается реже чем другие формы, но не менее мощная.

=head2 Циклы внутри Циклов

X<циклы; вложенность>

Вы может вкладывать циклы внутрь других циклов:

=begin programlisting

    for my $suit (@suits)
    {
        for my $values (@card_values) { ... }
    }

=end programlisting

Когда вы так делаете, используйте именные переменные итерации! Иначе
потенциальная путаница с актуальной переменной и её областью видимости слишком
велика.

Типичная ошибка с вложением C<foreach> и C<while> циклов -- это лёгкость
исчерпания файлового дескриптора с циклом C<while>:

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        # НЕ ИСПОЛЬЗОВАТЬ; похоже на кривой код
        while (<$fh>)
        {
            say $prefix, $_;
        }
    }

=end programlisting

Открытие файлового дескриптора вне цикла C<for> оставляет позицию в файле
неизменной между итерациями цикла C<for>. На второй итерации цикл C<while> не
сможет ничего прочесть и не будет выполнен. Для решения подобной проблемы,
переоткрывайте файл внутри цикла C<for> (легко для понимания, но не всегда
хорошее использование системных ресурсов), вычитывайте файл целиком в память
(что может не сработать если файл большой) или используйте C<seek> на файловом
дескрипторе для возврата в начало файла на каждой итерации (часто оставляемый
без внимания вариант):

=begin programlisting

    use autodie;

    open my $fh, '<', $some_file;

    for my $prefix (@prefixes)
    {
        while (<$fh>)
        {
            say $prefix, $_;
        }

        seek $fh, 0, 0;
    }

=end programlisting

=head2 Управление Циклом

X<циклы; управление>

Иногда Вам требуется прервать цикл до того как будет выполнено условное
выражение. Стандартный контрольный механизм Perl 5--исключения или
C<return>--работают, но Вы также можете использовать операторы I<контроля
цикла>.

X<циклы; C<next>>

Оператор I<next> перезапускает цикл со следующей итерации. Используйте его
тогда, когда выполнили все задачи в рамках данной итерации. Для прохода через
все строки файла, но с пропуском всего, что начинается с символа комментария
C<#>, запишите:

=begin programlisting

    while (<$fh>)
    {
        B<next> if /\A#/;
        ...
    }

=end programlisting

=begin tip Несколько Выходов вместо вложенных условий If

Сравните использование C<next> с альтернативой: оборачивание оставшегося кода
блока в C<if>. Теперь посмотрите, что случиться, если у вас несколько условий,
которые приводят к пропуску строки. Команды управления циклом с постфиксными
условиями могут сделать Ваш код гораздо более читаемым.

=end tip

X<циклы; C<last>>

Оператор I<last> немедленно завершает цикл. Для завершения обработки файла как
только вы увидите завершающую метку, запишите:

=begin programlisting

    while (<$fh>)
    {
        next if /\A#/;
        B<last> if /\A__END__/
        ...
    }

=end programlisting

X<циклы; C<redo>>

Оператор I<redo> перезапускает текущую итерацию без повторного вычисления
условия. Это может быть полезно в редких случаях, когда вы хотите
модифицировать прочтённую строку и начать обработку сначала без затирания её
следующей строкой. Для реализации простенького парсера файла, который
объединяет строки, которые завершаются символом обратной косой черты:

=begin programlisting

    while (my $line = <$fh>)
    {
        chomp $line;

        # совпадает с обратной косой чертой в конце строки
        if ($line =~ s{\\$}{})
        {
            $line .= <$fh>;
            chomp $line;
            redo;
        }

        ...
    }

=end programlisting

X<циклы; метки>

Использование операторов управления циклом во вложенных циклах может сбивать с
толку. Если Вы не можете избежать вложенных циклов--перенеся внутренний цикл в
отдельную функцию--используйте I<метку цикла> для уточнения:

=begin programlisting

    LINE:
    while (<$fh>)
    {
        chomp;

        PREFIX:
        for my $prefix (@prefixes)
        {
            next LINE unless $prefix;
            say "$prefix: $_";
            # next PREFIX неявно подразумевается здесь
        }
    }

=end programlisting

=head2 Continue

X<циклы; C<continue>>

Конструкция C<continue> ведёт себя как третье подвыражение цикла C<for>; Perl
выполняет её блок перед каждой последующей итерацией цикла, независимо
завершился ли цикл нормально или был перезапущен оператором C<next>N<Perl
эквивалент C оператору C<continue> является C<next>.>. Вы можете использовать
его с циклами C<while>, C<until>, C<when> или C<for>. Примеры C<continue>
редки, но они гарантируют, что что-либо всегда происходит с каждой итерацией
цикла, независимо от того, как завершилась итерация:

=begin programlisting

    while ($i < 10 )
    {
        next unless $i % 2;
        say $i;
    }
    continue
    {
        say 'Продолжаем...';
        $i++;
    }

=end programlisting

Будьте внимательны, блок C<continue> I<не> выполняется, когда происходит
завершение итерации цикла через C<last> или C<redo>.

=head2 Given/When

Z<given_when>

X<встроенные; C<given>>

Конструкция C<given> -- это новая возможность, появившаяся в Perl 5.10. Она
присваивает значение выражения актуальной переменной и выполняет блок:

=begin programlisting

    given ($name) { ... }

=end programlisting

В отличии от C<for>, она не производит итерации над элементом. Она вычисляет
его значение в скалярном контексте и всегда присваивает в актуальную
переменную:

=begin programlisting

    given (my $username = find_user())
    {
        is( $username, $_, 'авто-присвоение актуальной переменной' );
    }

=end programlisting

C<given> также локализует актуальную переменную:

=begin programlisting

    given ('mouse')
    {
        say;
        mouse_to_man( $_ );
        say;
    }

    sub mouse_to_man { s/mouse/man/ }

=end programlisting

X<встроенные; C<when>>
X<актуализация>

C<given> наиболее полезен, когда комбинируется с C<when> (L<smart_match>).
C<given> I<актуализирует> значение внутри блока так, что несколько операторов
C<when> могут сравнивать с актуальной переменной значение выражения, используя
семантику I<умного сравнения>. Напишем игру Камень, Ножницы, Бумага:

=begin programlisting

    my @options  = ( \&rock, \&paper, \&scissors );
    my $confused = "Я не понял вашего движения.";

    do
    {
        say "Камень, Ножницы, Бумага! Выберите одно: ";
        chomp( my $user = <STDIN> );
        my $computer_match = $options[ rand @options ];
        $computer_match->( lc( $user ) );
    } until (eof);

    sub rock
    {
        print "Я выбрал камень.  ";

        given (shift)
        {
            when (/бумага/)  { say 'Вы выиграли!' };
            when (/камень/)  { say 'Ничья!'  };
            when (/ножницы/) { say 'Я выиграл!'   };
            default          { say $confused  };
        }
    }

    sub paper
    {
        print "Я выбрал бумагу.  ";

        given (shift)
        {
            when (/бумага/)  { say 'Ничья!'  };
            when (/камень/)  { say 'Я выиграл!'   };
            when (/ножницы/) { say 'Вы выиграли!' };
            default          { say $confused  };
        }
    }

    sub scissors
    {
        print "Я выбрал ножницы.  ";

        given (shift)
        {
            when (/бумага/)  { say 'Я выиграл!'   };
            when (/камень/)  { say 'Вы выиграли!' };
            when (/ножницы/) { say 'Ничья!'  };
            default          { say $confused  };
        }
    }

=end programlisting

Perl выполнит правило C<default>, когда ни одно из условий не совпало.

=begin tip Упрощенный диспетчер с помощью Multimethods

X<CPAN; C<MooseX::MultiMethods>>

Модуль CPAN C<MooseX::MultiMethods> предоставляет другую технику, для
упрощения этого кода.

=end tip

=head2 Хвостовой вызов

Z<tailcalls>
X<хвостовой вызов>

I<Хвостовой вызов> происходит, когда последнее выражение внутри функции это
вызов другой функции--возвращаемое значение внешней функции есть результат,
возвращаемый внутренней функцией:

=begin programlisting

    sub log_and_greet_person
    {
        my $name = shift;
        log( "Приветствую $name" );

        return greet_person( $name );
    }

=end programlisting


Возвращаясь из C<greet_person()> напрямую к вызывающему
C<log_and_greet_person()> более эффективно, чем вернуться I<в>
C<log_and_greet_person()> и затем сразу I<из> C<log_and_greet_person()>.

Глубоко рекурсивный код (L<recursion>), особенно взаимно рекурсивный код может
потреблять много памяти. Хвостовой вызов уменьшает потребление памяти,
необходимой для внутренних целей контроля выполнения кода и может сделать
дорогостоящие алгоритмы приемлемыми.
К сожалению, Perl 5 не может автоматически выполнить эту оптимизацию; вы должны
сделать это сами, когда это необходимо.

X<встроенные; C<goto>>

Встроенная оператор C<goto> имеет форму, которая делает вызов функции как если
бы текущая функция никогда не вызывалась, по сути убирая накладные расходы по
вызову новой функции. Уродливый синтаксис смущает людей, которые слышали
правило "Никогда не использовать C<goto>", но это работает:

=begin programlisting

    sub log_and_greet_person
    {
        B<my ($name) = @_;>
        log( "Приветствую $name" );

        B<goto &greet_person>;
    }

=end programlisting

Данный пример имеет две важные особенности. Во-первых C<goto &function_name> или
C<goto &$function_reference> требует использования символа функции (C<&>), чтобы
парсер понял, что он выполняет хвостовой вызов, вместо переход по метке.
Во-вторых эта форма вызова функции косвенно передаёт содержимое C<@_> вызываемой
функции. Вы можете модифицировать C<@_> для изменения передаваемых параметров.

Эта техника относительно редкая; наиболее полезна, когда вы хотите
скорректировать управление выполнением кода, чтобы скрыться от функций,
проверяющие стек вызовов C<caller> (например, когда вы реализуете специальный
вид ведения логов или какой-либо вид отладки), или используйте алгоритм,
который требует большое число рекурсивных вызовов.
