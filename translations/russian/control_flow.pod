=head1 Порядок выполнения

Z<control_flow>

X<Порядок выполнения>

I<Порядок выполнения> в базовом Perl прямолинейный. Выполнение программы
начинается от начала (первая строка выполняемого файла) и продолжается до конца:

=begin programlisting

    say 'В начале';
    say 'В середине';
    say 'В конце';

=end programlisting

X<директивы порядка выполнения>

I<Директивы порядка выполнения> в Perl изменяют порядок выполнения -- что
следующее произойдёт в программе -- в зависимости от значения их выражений.

=head2 Директивы Ветвления

X<директивы порядка выполнения; C<if>>

Директива C<if> выполняет связанное действие, только если условное выражение
вычисляется в значение I<истины>:

=begin programlisting

    say 'Привет, Вася!' if $name eq 'Вася';

=end programlisting

Эта постфиксная форма удобна для простых выражений. Блоковая форма объединяет
несколько выражение в единый элемент:

=begin programlisting

    if ($name eq 'Вася')
    {
        say 'Привет, Вася!';
        found_vasya();
    }

=end programlisting

В то время, как блоковая форма требует окружающих скобок вокруг условия,
постфиксная форма их не требует.

Условное выражение может состоять из нескольких подвыражений, которое
вычисляется в одно выражение верхнего уровня:

=begin programlisting

    if ($name eq 'Вася' && not greeted_vasya())
    {
        say 'Привет, Вася!';
        found_vasya();
    }

=end programlisting

В постфиксной форме добавление скобок может прояснить смысл в ущерб визуальной
чистоте:

=begin programlisting

    greet_bob() if ($name eq 'Bob' && not greeted_bob());

=end programlisting

X<директивы порядка выполнения; C<unless>>

Директива C<unless> - это отрицательная форма C<if>. Perl выполнит действие,
когда условное выражение вычисляется в I<ложь>:

=begin programlisting

    say "Ты не Вася!" unless $name eq 'Вася';

=end programlisting

Так же как и C<if>, C<unless> также имеет блоковую форму, хотя многие
программисты стараются её избегать, так как сразу становиться трудно прочитать
её со сложными выражениями:

=begin programlisting

    unless (is_leap_year() and is_full_moon())
    {
        frolic();
        gambol();
    }

=end programlisting

C<unless> отлично работает с постфиксными условиями, особенно для для проверки
параметров в функциях (L<postfix_parameter_validation>):

=begin programlisting

    sub frolic
    {
        return unless @_;

        for my $chant (@_) { ... }
    }

=end programlisting

X<директивы порядка выполнения; C<else>>

Блоковые формы C<if> и C<unless> обе работают с директивой C<else>, которая даёт
код для выполнения, когда условное выражение не вычислено в истину (для C<if>)
или ложь (для C<unless>):

=begin programlisting

    if ($name eq 'Вася')
    {
        say 'Привет, Вася!';
        greet_user();
    }
    else
    {
        say "Я тебя не знаю.";
        shun_user();
    }

=end programlisting

Блоки C<else> позволяют вам переписывать условия C<if> на C<unless> и обратно:

=begin programlisting

    unless ($name eq 'Вася')
    {
        say "Я тебя не знаю.";
        shun_user();
    }
    else
    {
        say 'Привет, Боб!';
        greet_user();
    }

=end programlisting

Однако, получающееся двойное отрицание, при использовании C<unless> вместе с
блоком C<else>, может сбить с толку. Этот пример возможно единственное место,
где вы это вообще видите.

Раз Perl предоставляет оба C<if> и C<unless>, чтобы дать вам возможность
выражать ваши условия в наиболее читаемом виде, вы можете выбирать между
позитивным и негативным условным оператором:

=begin programlisting

    if ($name B<ne> 'Вася')
    {
        say "Я не знаю тебя.";
        shun_user();
    }
    else
    {
        say 'Привет, Вася!';
        greet_user();
    }

=end programlisting

... хотя двойное отрицание, получившееся с наличием блока C<else>, подсказывает
перевернуть условие.

X<директивы порядка выполнения; C<elsif>>

Одна или больше директив C<elsif> может следовать за блоком C<if> и может
предшествовать одиночному C<else>:

=begin programlisting

    if ($name eq 'Вася')
    {
        say 'Привет, Вася!';
        greet_user();
    }
    elsif ($name eq 'Петя')
    {
        say 'Привет, Петя!';
        greet_user();
    }
    else
    {
        say "Вы не мой дядя.";
        shun_user();
    }

=end programlisting

Цепочка C<unless> также может использовать C<elsif> блокN<Удачи в расшифровке
такого кода!>. Не существует C<elseunless>.

Запись C<else if> является синтаксической ошибкойN<Ларри предпочитает C<elsif>
по эстетическим соображениям, также как и в языке программирования Ada>

=begin programlisting

    if ($name eq 'Ринат')
    {
        say 'Привет, кузен!';
    }

    # warning; syntax error
    else if ($name eq 'Кристина')
    {
        say 'Привет, братаниха!';
    }

=end programlisting

=head2 Тернарный Условный Оператор

X<тернарное условие>
X<директивы порядка выполнения; тернарное условие>

I<Тернарный условынй оператор> - это оператор, вычисляющий условное выражение и
возвращающий одну из двух альтернатив:

=begin programlisting

    my $time_suffix = after_noon($time)
                    ? 'день'
                    : 'утро';

=end programlisting

Условное выражение предшествует знаку вопроса (C<?>) и символ двоеточия (C<:>)
разделяет альтернативы. Альтернативы - это выражения произвольной сложности --
включая другое тернарное условное выражение.

=begin sidebar

Интересный хоть и неочевидный приём - использовать тернарное условие для выбора
между альтернативными I<переменными>, а не только значениями:

=begin programlisting

    push @{ rand() > 0.5 ? \@red_team : \@blue_team },
        Player->new;

=end programlisting

Опять же, взвешивайте выгоду от ясности, против достоинства краткости.

=end sidebar

=head3 Сокращённое вычисление

Z<short_circuiting>
X<сокращённое вычисление>

Perl проявляет I<сокращённое вычисление>, когда он встречает сложные условные
выражения. Когда Perl может определить, что сложное выражение истинно или ложно
в целом без вычисления каждого подвыражения, он не выполняет последующие
подвыражения. Это станет ясно в следующем примере:

=begin programlisting

    say "Оба верны!" if ok( 1, 'первое подвыражение' )
                     && ok( 1, 'второе подвыражение' );

    done_testing();

=end programlisting

Возвращаемое значение C<ok()> (L<testing>) - это логическое значение, полученное
путём вычисления первого аргумента, поэтому этот код выведет:

=begin screen

    ok 1 - первое подвыражение
    ok 2 - второе подвыражение
    Оба верны!

=end screen

Когда первое подвыражение -- первый вызов C<ok> -- вычисляется в истинное
значение, Perl должен вычислить второе выражение. Если первое подвыражение было
вычислено как ложное значение, то нет необходимости вычислять следующее
подвыражение, так как выражение в целом уже не будет истинным:

=begin programlisting

    say "Оба верны!" if ok( 0, 'первое подвыражение' )
                     && ok( 1, 'второе подвыражение' );

=end programlisting

Этот пример выведет:

=begin screen

    not ok 1 - первое подвыражение

=end screen

Даже хотя второе выражение очевидно истинно, Perl никогда не вычисляет его.
Такое же сокращённое вычисление очевидно есть и для операций с логическим ИЛИ:

=begin programlisting

    say "Одно из двух верно!" if ok( 1, 'первое подвыражение' )
                              || ok( 1, 'второе подвыражение' );

=end programlisting

Этот пример выведет:

=begin screen

    ok 1 - первое подвыражение
    Одно из двух верно!

=end screen

С вычисленным истинным значением первого подвыражения, Perl может избежать
необходимости в вычислении второго подвыражения. Если первое подвыражение было
ложным, то вычисление второго подвыражения определило бы результат вычисления
всего выражения.

Кроме возможности избежать потенциально дорогостоящие вычисления, сокращённое
вычисление помогает избежать ошибок и предупреждений, как в случае, когда
использование неопределённого значения может привести к выводу предупреждения:

=begin programlisting

    my $bbq;
    if (defined $bbq and $bbq eq 'brisket') { ... }

=end programlisting

