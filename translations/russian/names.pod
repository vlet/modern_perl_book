=encoding utf8

=head1 Имена

Z<names>

X<имена>
X<идентификаторы>

I<Имена> (или I<идентификаторы>) повсюду содержатся в Perl программах:
переменные, функции, пакеты, классы и даже дескрипторы файлов. Все эти имена
начинаются с буквы или подчёркивания и могут также включать любые комбинации
букв, чисел и подчёркиваний. В случае, когда действует прагма C<utf8>
(L<unicode>), вы также можете использовать любые цифрочисловые UTF-8 символы как идентификатор. Все эти идентификаторы корректны в Perl:

=begin programlisting

    my $name;
    my @_private_names;
    my %Names_to_Addresses;

    sub anAwkwardName3;

    # with use utf8; enabled
    package Ingy::DE<ouml>t::Net;

=end programlisting

Это некорректные идентификаторы Perl:

=begin programlisting

    my $invalid name;
    my @3;
    my %~flags;

    package a-lisp-style-name;

=end programlisting

X<поиск символов>

I<Имена существуют только для удобства программиста>. Это правило применяется
только к буквенным именам, которые появляются как-есть в вашем исходном коде,
такие как C<sub fetch_pie> или C<my $waffleiron>. Только парсер Perl
устанавливает правила на имена идентификаторов.

Динамическая природа Perl позволяет вам ссылаться на сущности с именами
генерированными во время выполнения или переданными как входные данные в
программу. Этот I<поиск символов> придаёт гибкость ценой некоторого снижения
безопасности. В частности, неявный вызов функций или методов или поиск символов
в пространстве имён позволяет вам обойти проверку парсера Perl.

Делая это вы создаёте запутанный код. И как настоятельно рекомендует Джейсон
Домайнес (Jason Dominus) N<U<http://perl.plover.com/varvarname.html>>,
используйте хэши (L<hashes>) или вложенные структуры данных
(L<nested_data_structures>).

=head2 Имена Переменных и Сигилы

X<переменные; имена>
X<скалярные переменные>
X<переменные; скаляры>
X<скаляры>
X<массивы>
X<переменные; массивы>
X<хэши>
X<переменные; хэши>
X<сигил>

I<Имена переменных> всегда имеют предваряющий I<сигил> (символ), который
указывает какого типа является значение переменной. I<Скалярные переменные>
(L<scalars>) используют знак доллара (C<$>). I<Переменные массива> (L<arrays>)
используют знак (C<@>). I<Переменные хэша> (L<hashes>) используют символ (C<%>):

=begin programlisting

    my $scalar;
    my @array;
    my %hash;

=end programlisting

Эти сигилы задают визуальное пространство имён для имён переменных. Возможно --
хотя это и сбивает с толку -- объявить несколько переменных с одним именем, но
разных типов:

=begin programlisting

    my ($bad_name, @bad_name, %bad_name);

=end programlisting

Хоть Perl это и не смутит, но вот людей, читающие это код, - может.

X<варьирующий сигил>

Сигилы Perl 5 - I<варьирующие сигилы>. Как задаёт контекст количество элементов,
которые вы ожидаете от операции, или какого типа данные вы ожидаете получить,
так и сигил определяет как вы манипулируете с данными переменной. Например, для
доступа к одному элементу массива или хэша вы должны использовать скалярный
сигил (C<$>):

=begin programlisting

    my $hash_element  = $hash{ $key };
    my $array_element = $array[ $index ]

    $hash{ $key }     = 'value';
    $array[ $index ]  = 'item';

=end programlisting

X<lvalue>
X<rvalue>

Параллель с числовым контекстом здесь важна. Используя скалярный элемент
конструкции, как I<lvalue> (результат присвоения, по левую сторону символа
C<=>) устанавливает скалярный контекст (L<context_philosophy>) на I<rvalue>
(присваиваемое значение, по правую сторону символа C<=>).

X<срезы>

По аналогии, доступ к множеству элементов хэша или массива -- операция
известная, как I<срез> -- использует символ (C<@>) и устанавливает списочный
контекстN<... даже если список сам по себе имеет один элемент или ни одного>:

=begin programlisting

    my @hash_elements  = @hash{ @keys };
    my @array_elements = @array[ @indexes ];

    my %hash;
    @hash{ @keys }     = @values;

=end programlisting

Наиболее надёжный способ определения типа переменной -- скаляр, массив или хэш
-- посмотреть на операцию, производимой над ним. Скаляры поддерживают все
базовые операции, такие как манипуляции со строками, числами и логическими
значениями. Массивы поддерживают доступ по индексам через квадратные скобки.
Хэши поддерживают доступ к ключам через фигурные скобки.

=head2 Пространства Имён

X<полное имя>
X<пространство имён>

Perl предоставляет механизм для группирования сходных функций и переменных в их
собственное уникальное именованное пространство -- I<пространство имён>
(L<packages>). Пространство имён - это именованное множество символов. Perl
допускает многоуровневое пространство имён с именами, соединёнными двойным
двоеточием (C<::>), где C<DessertShop::IceCream> ссылается на логическое
множество связанных переменных и функций, таких как C<scoop()> и
C<pour_hot_fudge()>.

Внутри пространства имён вы можете использовать короткие имена его элементов.
Вне этого пространства имён, нужно ссылаться на элемент с помощью I<полного
имени>. Так, например, внутри C<DessertShop::IceCream>, C<add_sprinkles()>
ссылается на ту же функцию, что и C<DessertShop::IceCream::add_sprinkles()> вне
этого пространства имён.

Хоть стандарты именования применяются и к именам пакетов, но по принятому
соглашению все пользовательские пакеты начинаются с заглавной буквы. За базовым
Perl зарезервированы имена со строчными буквами для базовых прагм (L<pragmas>),
такие как C<strict> и C<warnings>. Эта политика введена прежде всего по указанию
сообщества.

Все пространства имён в Perl 5 видимы глобально. Когда Perl ищет символ в
C<DessertShop::IceCream::Freezer>, он ищет в таблице символов C<main::> символ
представляющий пространство имён C<DessertShop::>, затем в нём ищет пространство
имён C<IceCream::> и так далее. C<Freezer::> видим внутри пространства имён
C<IceCream::>. Вложенность одного в другой в последнем случае - это только
механизм хранения и не подразумевает никаких выводов о взаимоотношении дочернего
и родительского пакетов. Только программист может сделать I<логические>
отношения между элементами очевидными -- выбрав подходящие имена и правильно
организовав их.
